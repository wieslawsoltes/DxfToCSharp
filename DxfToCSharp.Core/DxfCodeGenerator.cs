using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Globalization;
using netDxf;
using netDxf.Entities;
using netDxf.Objects;
using netDxf.Tables;
using PointEntity = netDxf.Entities.Point;

namespace DxfToCSharp.Core;

public class DxfCodeGenerator
{
    private static string F(double v) => v.ToString("G17", CultureInfo.InvariantCulture);

    private string GenerateEnumFlags<T>(T enumValue) where T : Enum
    {
        var enumType = typeof(T);
        var enumName = enumType.Name;
        var value = Convert.ToInt32(enumValue);
        
        if (value == 0)
        {
            return $"{enumName}.None";
        }
        
        var flags = new List<string>();
        foreach (var enumVal in Enum.GetValues(enumType))
        {
            var intVal = Convert.ToInt32(enumVal);
            if (intVal != 0 && (value & intVal) == intVal)
            {
                flags.Add($"{enumName}.{enumVal}");
            }
        }
        
        return flags.Count > 0 ? string.Join(" | ", flags) : $"{enumName}.None";
    }
    private readonly HashSet<string> _usedLayers = new();
    private readonly HashSet<string> _usedLinetypes = new();
    private readonly HashSet<string> _usedTextStyles = new();
    private readonly HashSet<string> _usedBlocks = new();
    private readonly HashSet<string> _usedDimensionStyles = new();
    private readonly HashSet<string> _usedMLineStyles = new();
    private readonly HashSet<string> _usedUCS = new();
    private readonly HashSet<string> _usedVPorts = new();
    private int _insertCounter = 0;

    public string Generate(DxfDocument doc, string? sourcePath, string? className = null, DxfCodeGenerationOptions? options = null)
    {
        // Use provided options or create default
        options ??= DxfCodeGenerationOptions.CreateDefault();
        
        var allEntities = doc.Entities.All?.ToList() ?? new List<EntityObject>();
        
        // Clear collections for fresh generation
        _usedLayers.Clear();
        _usedLinetypes.Clear();
        _usedTextStyles.Clear();
        _usedBlocks.Clear();
        _usedDimensionStyles.Clear();
        _usedMLineStyles.Clear();
        _usedUCS.Clear();
        _usedVPorts.Clear();
        _insertCounter = 0;

        var sb = new StringBuilder();
        
        // Use provided class name, options class name, or default
        var finalClassName = className ?? options.CustomClassName ?? "DxfDocumentGenerator";
        
        // Header and using statements
        GenerateHeader(sb, sourcePath, options);
        
        // Analyze what tables we need (only if generating any tables)
        if (options.GenerateLayers || options.GenerateLinetypes || options.GenerateTextStyles || 
            options.GenerateBlocks || options.GenerateDimensionStyles || options.GenerateMLineStyles || options.GenerateUCS || options.GenerateVPorts)
        {
            AnalyzeUsedTables(allEntities, options);
        }
        
        // Class definition start
        sb.AppendLine($"public static class {finalClassName}");
        sb.AppendLine("{");
        sb.AppendLine("    public static DxfDocument Create()");
        sb.AppendLine("    {");
        sb.AppendLine("        var doc = new DxfDocument();");
        sb.AppendLine();
        
        // Generate table definitions
        GenerateTableDefinitions(sb, doc, options);
        
        // Generate entities
        if (options.GenerateEntities)
        {
            GenerateEntities(sb, allEntities, options);
        }
        
        // Footer
        sb.AppendLine();
        if (options.GenerateSaveComment)
        {
            sb.AppendLine("        // Save or return the document");
            var saveFileName = !string.IsNullOrEmpty(sourcePath) 
                ? System.IO.Path.GetFileName(sourcePath) 
                : $"{finalClassName.ToLowerInvariant()}.dxf";
            sb.AppendLine($"        // doc.Save(\"{saveFileName}\");");
        }
        if (options.GenerateReturnStatement)
        {
            sb.AppendLine("        return doc;");
        }
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private void GenerateHeader(StringBuilder sb, string? sourcePath, DxfCodeGenerationOptions options)
    {
        if (options.GenerateHeader)
        {
            sb.AppendLine("/// <auto-generated>");
            sb.AppendLine("/// This code was generated by DxfToCSharp.");
            sb.AppendLine("/// </auto-generated>");
            if (!string.IsNullOrEmpty(sourcePath))
                sb.AppendLine($"// Source: {System.IO.Path.GetFileName(sourcePath)}");
            sb.AppendLine($"// Generated: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
            sb.AppendLine();
        }
        
        if (options.GenerateUsingStatements)
        {
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using netDxf;");
            sb.AppendLine("using netDxf.Entities;");
            sb.AppendLine("using netDxf.Objects;");
            sb.AppendLine("using netDxf.Tables;");
            sb.AppendLine("using netDxf.Blocks;");
            sb.AppendLine("using netDxf.Units;");
            sb.AppendLine();
        }
    }

    private void AnalyzeUsedTables(List<EntityObject> entities, DxfCodeGenerationOptions options)
    {
        foreach (var entity in entities)
        {
            if (options.GenerateLayers && entity.Layer != null)
                _usedLayers.Add(entity.Layer.Name);
            if (options.GenerateLinetypes && entity.Linetype != null)
                _usedLinetypes.Add(entity.Linetype.Name);
            
            // Check for text entities that use text styles
            if (options.GenerateTextStyles)
            {
                if (entity is Text text && text.Style != null)
                    _usedTextStyles.Add(text.Style.Name);
                else if (entity is MText mtext && mtext.Style != null)
                    _usedTextStyles.Add(mtext.Style.Name);
            }
            
            // Check for Insert entities that use blocks
            if (options.GenerateBlocks && entity is Insert insert && insert.Block != null)
                _usedBlocks.Add(insert.Block.Name);
            
            // Check for Leader entities that use dimension styles
            if (options.GenerateDimensionStyles)
            {
                if (entity is Leader leader && leader.Style != null)
                    _usedDimensionStyles.Add(leader.Style.Name);
                
                // Check for Dimension entities that use dimension styles
                if (entity is Dimension dimension && dimension.Style != null)
                    _usedDimensionStyles.Add(dimension.Style.Name);
            }
            
            // Check for MLine entities that use multiline styles
            if (options.GenerateMLineStyles && entity is MLine mline && mline.Style != null)
                _usedMLineStyles.Add(mline.Style.Name);
        }
        
        // Analyze UCS objects (they are not directly referenced by entities but are part of document structure)
        if (options.GenerateUCS)
        {
            AnalyzeUsedUCS(entities, options);
        }
        
        // Analyze VPort objects (they are not directly referenced by entities but are part of document structure)
        if (options.GenerateVPorts)
        {
            AnalyzeUsedVPorts(entities, options);
        }
    }

    private void AnalyzeUsedUCS(List<EntityObject> entities, DxfCodeGenerationOptions options)
    {
        // For now, we'll include all UCS objects in the document since they are typically
        // standalone coordinate system definitions that may be referenced by name
        // In a more sophisticated implementation, we could track which UCS objects are actually used
    }

    private void AnalyzeUsedVPorts(List<EntityObject> entities, DxfCodeGenerationOptions options)
    {
        // For now, we'll include all VPort objects in the document since they are typically
        // viewport definitions that may be referenced by name
        // In a more sophisticated implementation, we could track which VPort objects are actually used
        
        // Always include the active viewport (*Active) as it's commonly modified
        _usedVPorts.Add("*Active");
    }

    private void GenerateTableDefinitions(StringBuilder sb, DxfDocument doc, DxfCodeGenerationOptions options)
    {
        // Generate layer definitions
        if (options.GenerateLayers && _usedLayers.Count > 0)
        {
            sb.AppendLine("        // Layer definitions");
            foreach (var layerName in _usedLayers.OrderBy(x => x))
            {
                var layer = doc.Layers.FirstOrDefault(l => l.Name == layerName);
                if (layer != null)
                {
                    sb.AppendLine($"        var layer{SafeName(layerName)} = new Layer(\"{Escape(layerName)}\")");
                    sb.AppendLine("        {");
                    if (layer.Color.Index != 7) // Default color is 7 (white)
                        sb.AppendLine($"            Color = new AciColor({layer.Color.Index}),");
                    if (layer.Lineweight != Lineweight.Default)
                        sb.AppendLine($"            Lineweight = Lineweight.{layer.Lineweight},");
                    if (!layer.IsVisible)
                        sb.AppendLine("            IsVisible = false,");
                    if (layer.IsFrozen)
                        sb.AppendLine("            IsFrozen = true,");
                    if (layer.IsLocked)
                        sb.AppendLine("            IsLocked = true,");
                    sb.AppendLine("        };");
                    sb.AppendLine($"        doc.Layers.Add(layer{SafeName(layerName)});");
                    sb.AppendLine();
                }
                else if (layerName == "0")
                {
                    // Handle default layer "0" which might not be in the layers collection
                    sb.AppendLine($"        var layer{SafeName(layerName)} = doc.Layers[\"{layerName}\"];");
                    sb.AppendLine();
                }
            }
        }

        // Generate linetype definitions (if any custom ones)
        if (options.GenerateLinetypes && _usedLinetypes.Any(lt => lt != "Continuous" && lt != "ByLayer" && lt != "ByBlock"))
        {
            sb.AppendLine("        // Linetype definitions");
            foreach (var linetypeName in _usedLinetypes.Where(lt => lt != "Continuous" && lt != "ByLayer" && lt != "ByBlock"))
            {
                var linetype = doc.Linetypes.FirstOrDefault(lt => lt.Name == linetypeName);
                if (linetype != null)
                {
                    sb.AppendLine($"        var linetype{SafeName(linetypeName)} = new Linetype(\"{Escape(linetypeName)}\");");
                    sb.AppendLine($"        doc.Linetypes.Add(linetype{SafeName(linetypeName)});");
                }
            }
            sb.AppendLine();
        }

        // Generate text style definitions (if any custom ones)
        if (options.GenerateTextStyles && _usedTextStyles.Any(ts => ts != "Standard"))
        {
            sb.AppendLine("        // Text style definitions");
            foreach (var styleName in _usedTextStyles.Where(ts => ts != "Standard"))
            {
                var style = doc.TextStyles.FirstOrDefault(ts => ts.Name == styleName);
                if (style != null)
                {
                    // Use the required constructor parameters for TextStyle
                    string fontFile = !string.IsNullOrEmpty(style.FontFile) ? style.FontFile : TextStyle.DefaultFont;
                    sb.AppendLine($"        var textStyle{SafeName(styleName)} = new TextStyle(\"{Escape(styleName)}\", \"{Escape(fontFile)}\");");
                    sb.AppendLine($"        doc.TextStyles.Add(textStyle{SafeName(styleName)});");
                }
            }
            sb.AppendLine();
        }

        // Generate block definitions (if any used)
        if (options.GenerateBlocks && _usedBlocks.Count > 0)
        {
            sb.AppendLine("        // Block definitions");
            foreach (var blockName in _usedBlocks.OrderBy(x => x))
            {
                var block = doc.Blocks.FirstOrDefault(b => b.Name == blockName);
                if (block != null)
                {
                    sb.AppendLine($"        var block{SafeName(blockName)} = new Block(\"{Escape(blockName)}\")");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            Origin = new Vector3({F(block.Origin.X)}, {F(block.Origin.Y)}, {F(block.Origin.Z)}),");
                    if (!string.IsNullOrEmpty(block.Description))
                        sb.AppendLine($"            Description = \"{Escape(block.Description)}\",");
                    if (block.Layer?.Name != "0" && block.Layer != null)
                        sb.AppendLine($"            Layer = new Layer(\"{Escape(block.Layer.Name)}\"),");
                    sb.AppendLine("        };");
                    
                    // Add attribute definitions if any
                    if (block.AttributeDefinitions.Count > 0)
                    {
                        sb.AppendLine("        // Add attribute definitions to block");
                        foreach (var attDef in block.AttributeDefinitions.Values)
                        {
                            sb.AppendLine($"        var attDef{SafeName(blockName)}{SafeName(attDef.Tag)} = new AttributeDefinition(\"{Escape(attDef.Tag)}\")");
                            sb.AppendLine("        {");
                            sb.AppendLine($"            Prompt = \"{Escape(attDef.Prompt)}\",");
                            sb.AppendLine($"            Position = new Vector3({F(attDef.Position.X)}, {F(attDef.Position.Y)}, {F(attDef.Position.Z)}),");
                            sb.AppendLine($"            Height = {F(attDef.Height)},");
                            if (!string.IsNullOrEmpty(attDef.Value))
                                sb.AppendLine($"            Value = \"{Escape(attDef.Value)}\",");
                            if (Math.Abs(attDef.Rotation) > 1e-12)
                                sb.AppendLine($"            Rotation = {F(attDef.Rotation)},");
                            sb.AppendLine("        };");
                            sb.AppendLine($"        block{SafeName(blockName)}.AttributeDefinitions.Add(attDef{SafeName(blockName)}{SafeName(attDef.Tag)});");
                        }
                        sb.AppendLine();
                    }
                    
                    // Add block entities
                    if (block.Entities.Count > 0)
                    {
                        sb.AppendLine("        // Add entities to block");
                        foreach (var entity in block.Entities)
                        {
                            // Generate simplified entity code for block entities
                            GenerateBlockEntity(sb, entity, blockName, options);
                        }
                        sb.AppendLine();
                    }
                    
                    sb.AppendLine($"        doc.Blocks.Add(block{SafeName(blockName)});");
                    sb.AppendLine();
                }
            }
        }
        
        // Generate dimension style definitions (if any custom ones)
        if (options.GenerateDimensionStyles && _usedDimensionStyles.Any(ds => ds != "Standard"))
        {
            sb.AppendLine("        // Dimension style definitions");
            foreach (var styleName in _usedDimensionStyles.Where(ds => ds != "Standard"))
            {
                var style = doc.DimensionStyles.FirstOrDefault(ds => ds.Name == styleName);
                if (style != null)
                {
                    sb.AppendLine($"        var dimStyle{SafeName(styleName)} = new DimensionStyle(\"{Escape(styleName)}\");");
                    sb.AppendLine($"        doc.DimensionStyles.Add(dimStyle{SafeName(styleName)});");
                }
            }
            sb.AppendLine();
        }
        
        // Generate multiline style definitions (if any custom ones)
        if (options.GenerateMLineStyles && _usedMLineStyles.Any(ms => ms != "Standard"))
        {
            sb.AppendLine("        // Multiline style definitions");
            foreach (var styleName in _usedMLineStyles.Where(ms => ms != "Standard"))
            {
                var style = doc.MlineStyles.FirstOrDefault(ms => ms.Name == styleName);
                if (style != null)
                {
                    sb.AppendLine($"        var mlineStyle{SafeName(styleName)} = new MLineStyle(\"{Escape(styleName)}\");");
                    sb.AppendLine($"        doc.MLineStyles.Add(mlineStyle{SafeName(styleName)});");
                }
            }
            sb.AppendLine();
        }
        
        // Generate UCS definitions (if any custom ones)
        if (options.GenerateUCS && doc.UCSs.Count > 0)
        {
            sb.AppendLine("        // UCS definitions");
            foreach (var ucs in doc.UCSs.Where(u => u.Name != "*ACTIVE"))
             {
                 sb.AppendLine($"        var ucs{SafeName(ucs.Name)} = new UCS(");
                 sb.AppendLine($"            \"{Escape(ucs.Name)}\",");
                 sb.AppendLine($"            new Vector3({F(ucs.Origin.X)}, {F(ucs.Origin.Y)}, {F(ucs.Origin.Z)}),");
                 sb.AppendLine($"            new Vector3({F(ucs.XAxis.X)}, {F(ucs.XAxis.Y)}, {F(ucs.XAxis.Z)}),");
                 sb.AppendLine($"            new Vector3({F(ucs.YAxis.X)}, {F(ucs.YAxis.Y)}, {F(ucs.YAxis.Z)}));");
                 sb.AppendLine($"        doc.UCSs.Add(ucs{SafeName(ucs.Name)});");
                 sb.AppendLine();
             }
        }
        
        // Generate VPort definitions (modify the active viewport)
        if (options.GenerateVPorts && _usedVPorts.Count > 0 && doc.Viewport != null)
        {
            var vport = doc.Viewport;
            sb.AppendLine("        // VPort (Viewport) configuration");
            sb.AppendLine("        var activeViewport = doc.Viewport;");
            
            // Only set properties that differ from defaults
            
            if (vport.ViewCenter.X != 0 || vport.ViewCenter.Y != 0)
                sb.AppendLine($"        activeViewport.ViewCenter = new Vector2({F(vport.ViewCenter.X)}, {F(vport.ViewCenter.Y)});");
            
            if (Math.Abs(vport.ViewHeight - 10) > 1e-6) // Default height is 10
                sb.AppendLine($"        activeViewport.ViewHeight = {F(vport.ViewHeight)};");
            
            if (Math.Abs(vport.ViewAspectRatio - 1.0) > 1e-6) // Default aspect ratio is 1.0
                sb.AppendLine($"        activeViewport.ViewAspectRatio = {F(vport.ViewAspectRatio)};");
            
            if (vport.ViewTarget.X != 0 || vport.ViewTarget.Y != 0 || vport.ViewTarget.Z != 0)
                sb.AppendLine($"        activeViewport.ViewTarget = new Vector3({F(vport.ViewTarget.X)}, {F(vport.ViewTarget.Y)}, {F(vport.ViewTarget.Z)});");
            
            if (vport.ViewDirection.X != 0 || vport.ViewDirection.Y != 0 || Math.Abs(vport.ViewDirection.Z - 1) > 1e-6) // Default direction is UnitZ
                sb.AppendLine($"        activeViewport.ViewDirection = new Vector3({F(vport.ViewDirection.X)}, {F(vport.ViewDirection.Y)}, {F(vport.ViewDirection.Z)});");
            
            if (!vport.ShowGrid) // Default is true
                sb.AppendLine("        activeViewport.ShowGrid = false;");
            
            if (vport.SnapMode) // Default is false
                sb.AppendLine("        activeViewport.SnapMode = true;");
            
            if (Math.Abs(vport.SnapSpacing.X - 0.5) > 1e-6 || Math.Abs(vport.SnapSpacing.Y - 0.5) > 1e-6) // Default is 0.5
                sb.AppendLine($"        activeViewport.SnapSpacing = new Vector2({F(vport.SnapSpacing.X)}, {F(vport.SnapSpacing.Y)});");
            
            if (Math.Abs(vport.GridSpacing.X - 10.0) > 1e-6 || Math.Abs(vport.GridSpacing.Y - 10.0) > 1e-6) // Default is 10.0
                sb.AppendLine($"        activeViewport.GridSpacing = new Vector2({F(vport.GridSpacing.X)}, {F(vport.GridSpacing.Y)});");
            
            if (vport.SnapBasePoint.X != 0 || vport.SnapBasePoint.Y != 0)
                sb.AppendLine($"        activeViewport.SnapBasePoint = new Vector2({F(vport.SnapBasePoint.X)}, {F(vport.SnapBasePoint.Y)});");
            
            sb.AppendLine();
        }
    }

    private void GenerateEntities(StringBuilder sb, List<EntityObject> entities, DxfCodeGenerationOptions options)
    {
        sb.AppendLine("        // Entities");
        
        // Group entities by type if requested
        if (options.GroupEntitiesByType)
        {
            var groupedEntities = entities.GroupBy(e => e.GetType()).OrderBy(g => g.Key.Name);
            foreach (var group in groupedEntities)
            {
                sb.AppendLine($"        // {group.Key.Name} entities");
                foreach (var entity in group)
                {
                    GenerateEntity(sb, entity, options);
                }
                sb.AppendLine();
            }
        }
        else
        {
            foreach (var entity in entities)
            {
                GenerateEntity(sb, entity, options);
            }
        }
    }

    private void GenerateEntity(StringBuilder sb, EntityObject entity, DxfCodeGenerationOptions options)
    {
        if (options.GenerateDetailedComments)
        {
            sb.AppendLine($"        // {entity.GetType().Name}: {entity.Handle}");
        }
        
        switch (entity)
        {
            case Line line when options.GenerateLineEntities:
                GenerateLine(sb, line);
                break;
            case Arc arc when options.GenerateArcEntities:
                GenerateArc(sb, arc);
                break;
            case Circle circle when options.GenerateCircleEntities:
                GenerateCircle(sb, circle);
                break;
            case PointEntity point when options.GeneratePointEntities:
                GeneratePoint(sb, point);
                break;
            case Polyline2D poly2d when options.GeneratePolylineEntities:
                GeneratePolyline2D(sb, poly2d);
                break;
            case Polyline3D poly3d when options.GeneratePolylineEntities:
                GeneratePolyline3D(sb, poly3d);
                break;
            case Spline spline when options.GenerateSplineEntities:
                GenerateSpline(sb, spline);
                break;
            case Text text when options.GenerateTextEntities:
                GenerateText(sb, text);
                break;
            case MText mtext when options.GenerateMTextEntities:
                GenerateMText(sb, mtext);
                break;
            case Ellipse ellipse when options.GenerateEllipseEntities:
                GenerateEllipse(sb, ellipse);
                break;
            case Insert insert when options.GenerateInsertEntities:
                GenerateInsert(sb, insert);
                break;
            case Hatch hatch when options.GenerateHatchEntities:
                GenerateHatch(sb, hatch, options);
                break;
            case Wipeout wipeout when options.GenerateWipeoutEntities:
                GenerateWipeout(sb, wipeout);
                break;
            case Leader leader when options.GenerateLeaderEntities:
                GenerateLeader(sb, leader);
                break;
            case Face3D face3d when options.GenerateFace3dEntities:
                GenerateFace3D(sb, face3d);
                break;
            case LinearDimension linearDim when options.GenerateDimensionEntities && options.GenerateLinearDimensionEntities:
                GenerateLinearDimension(sb, linearDim);
                break;
            case AlignedDimension alignedDim when options.GenerateDimensionEntities && options.GenerateAlignedDimensionEntities:
                GenerateAlignedDimension(sb, alignedDim);
                break;
            case RadialDimension radialDim when options.GenerateDimensionEntities && options.GenerateRadialDimensionEntities:
                GenerateRadialDimension(sb, radialDim);
                break;
            case DiametricDimension diametricDim when options.GenerateDimensionEntities && options.GenerateDiametricDimensionEntities:
                GenerateDiametricDimension(sb, diametricDim);
                break;
            case Angular2LineDimension angular2LineDim when options.GenerateDimensionEntities && options.GenerateAngular2LineDimensionEntities:
                GenerateAngular2LineDimension(sb, angular2LineDim);
                break;
            case Angular3PointDimension angular3PointDim when options.GenerateDimensionEntities && options.GenerateAngular3PointDimensionEntities:
                GenerateAngular3PointDimension(sb, angular3PointDim);
                break;
            case OrdinateDimension ordinateDim when options.GenerateDimensionEntities && options.GenerateOrdinateDimensionEntities:
                GenerateOrdinateDimension(sb, ordinateDim);
                break;
            case Ray ray when options.GenerateRayEntities:
                GenerateRay(sb, ray);
                break;
            case XLine xline when options.GenerateXLineEntities:
                GenerateXLine(sb, xline);
                break;
            case Solid solid when options.GenerateSolidEntities:
                GenerateSolid(sb, solid);
                break;
            case MLine mline when options.GenerateMLineEntities:
                GenerateMLine(sb, mline);
                break;
            case Image image when options.GenerateImageEntities:
                GenerateImage(sb, image);
                break;
            case Mesh mesh when options.GenerateMeshEntities:
                GenerateMesh(sb, mesh);
                break;
            case PolyfaceMesh polyfaceMesh when options.GeneratePolyfaceMeshEntities:
                GeneratePolyfaceMesh(sb, polyfaceMesh);
                break;
            case PolygonMesh polygonMesh when options.GeneratePolygonMeshEntities:
                GeneratePolygonMesh(sb, polygonMesh);
                break;
            case Shape shape when options.GenerateShapeEntities:
                GenerateShape(sb, shape);
                break;
            case Tolerance tolerance when options.GenerateToleranceEntities:
                GenerateTolerance(sb, tolerance);
                break;
            case Trace trace when options.GenerateTraceEntities:
                GenerateTrace(sb, trace);
                break;
            case Underlay underlay when options.GenerateUnderlayEntities:
                GenerateUnderlay(sb, underlay);
                break;
            case Viewport viewport when options.GenerateViewportEntities:
                GenerateViewport(sb, viewport);
                break;
            default:
                 if (options.GenerateDetailedComments)
                 {
                     sb.AppendLine($"        // Skipped entity type: {entity.GetType().Name}");
                 }
                 break;
        }
    }

    private void GenerateLine(StringBuilder sb, Line line)
    {
        sb.AppendLine("        doc.Entities.Add(");
        GenerateLineConstructor(sb, line, "        ");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, line);
        sb.AppendLine("        }");
        sb.AppendLine("        );");
    }

    private void GenerateLineConstructor(StringBuilder sb, Line line, string indent)
    {
        sb.AppendLine($"{indent}new Line(");
        sb.AppendLine($"{indent}    new Vector3({F(line.StartPoint.X)}, {F(line.StartPoint.Y)}, {F(line.StartPoint.Z)}),");
        sb.AppendLine($"{indent}    new Vector3({F(line.EndPoint.X)}, {F(line.EndPoint.Y)}, {F(line.EndPoint.Z)}))");
    }

    private void GenerateArc(StringBuilder sb, Arc arc)
    {
        sb.AppendLine("        doc.Entities.Add(");
        GenerateArcConstructor(sb, arc, "        ");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, arc);
        sb.AppendLine("        }");
        sb.AppendLine("        );");
    }

    private void GenerateArcConstructor(StringBuilder sb, Arc arc, string indent)
    {
        sb.AppendLine($"{indent}new Arc(");
        sb.AppendLine($"{indent}    new Vector3({F(arc.Center.X)}, {F(arc.Center.Y)}, {F(arc.Center.Z)}),");
        sb.AppendLine($"{indent}    {F(arc.Radius)}, {F(arc.StartAngle)}, {F(arc.EndAngle)})");
    }

    private void GenerateCircle(StringBuilder sb, Circle circle)
    {
        sb.AppendLine("        doc.Entities.Add(");
        GenerateCircleConstructor(sb, circle, "        ");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, circle);
        sb.AppendLine("        }");
        sb.AppendLine("        );");
    }

    private void GenerateCircleConstructor(StringBuilder sb, Circle circle, string indent)
    {
        sb.AppendLine($"{indent}new Circle(");
        sb.AppendLine($"{indent}    new Vector3({F(circle.Center.X)}, {F(circle.Center.Y)}, {F(circle.Center.Z)}),");
        sb.AppendLine($"{indent}    {F(circle.Radius)})");
    }

    private void GeneratePoint(StringBuilder sb, PointEntity point)
    {
        sb.AppendLine($"        doc.Entities.Add(");
        sb.AppendLine($"        new Point(");
        sb.AppendLine($"            new Vector3({F(point.Position.X)}, {F(point.Position.Y)}, {F(point.Position.Z)}))");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, point);
        sb.AppendLine("        }");
        sb.AppendLine("        );");
    }

    private void GeneratePolyline2D(StringBuilder sb, Polyline2D poly2d)
    {
        sb.AppendLine("        doc.Entities.Add(");
        GeneratePolyline2DConstructor(sb, poly2d, "        ");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, poly2d);
        if (Math.Abs(poly2d.Elevation) > 1e-12)
        {
            sb.AppendLine($"            Elevation = {F(poly2d.Elevation)},");
        }
        sb.AppendLine("        }");
        sb.AppendLine("        );");
    }

    private void GeneratePolyline2DConstructor(StringBuilder sb, Polyline2D poly2d, string indent)
    {
        sb.AppendLine($"{indent}new Polyline2D(new List<Polyline2DVertex>()");
        sb.AppendLine($"{indent}{{");
        foreach (var vertex in poly2d.Vertexes)
        {
            string bulgeStr = Math.Abs(vertex.Bulge) > 1e-12 ? $" {{ Bulge = {F(vertex.Bulge)} }}" : "";
            sb.AppendLine($"{indent}    new Polyline2DVertex({F(vertex.Position.X)}, {F(vertex.Position.Y)}){bulgeStr},");
        }
        sb.AppendLine($"{indent}}}, {(poly2d.IsClosed ? "true" : "false")})");
    }

    private void GeneratePolyline3D(StringBuilder sb, Polyline3D poly3d)
    {
        sb.AppendLine("        doc.Entities.Add(new Polyline3D(new List<Polyline3DVertex>()");
        sb.AppendLine("        {");
        foreach (var v in poly3d.Vertexes)
        {
            sb.AppendLine($"            new Polyline3DVertex({F(v.X)}, {F(v.Y)}, {F(v.Z)}),");
        }
        sb.AppendLine($"        }}, {(poly3d.IsClosed ? "true" : "false")});");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, poly3d);
        sb.AppendLine("        }");
        sb.AppendLine("        );");
    }

    private void GenerateSpline(StringBuilder sb, Spline spline)
    {
        // Generate spline with complete definition: control points, weights, and degree
        sb.AppendLine("        {");
        sb.AppendLine("            var controlPoints = new List<Vector3>");
        sb.AppendLine("            {");
        foreach (var cp in spline.ControlPoints)
        {
            sb.AppendLine($"                new Vector3({F(cp.X)}, {F(cp.Y)}, {F(cp.Z)}),");
        }
        sb.AppendLine("            };");
        sb.AppendLine();
        
        sb.AppendLine("            var weights = new List<double>");
        sb.AppendLine("            {");
        foreach (var weight in spline.Weights)
        {
            sb.AppendLine($"                {F(weight)},");
        }
        sb.AppendLine("            };");
        sb.AppendLine();
        
        sb.AppendLine($"            var splineEntity = new Spline(controlPoints, weights, {spline.Degree});");
        
        // Apply entity properties
        if (spline.Layer != null && _usedLayers.Contains(spline.Layer.Name))
        {
            sb.AppendLine($"            splineEntity.Layer = layer{SafeName(spline.Layer.Name)};");
        }
        
        // Color handling
        if (spline.Color.Index != 256) // Not ByLayer
        {
            if (spline.Color.Index == 0)
                sb.AppendLine("            splineEntity.Color = AciColor.ByBlock;");
            else if (spline.Color.Index >= 1 && spline.Color.Index <= 255)
                sb.AppendLine($"            splineEntity.Color = new AciColor({spline.Color.Index});");
        }
        
        // Linetype
        if (spline.Linetype != null && spline.Linetype.Name != "ByLayer" && spline.Linetype.Name != "Continuous")
        {
            sb.AppendLine($"            splineEntity.Linetype = linetype{SafeName(spline.Linetype.Name)};");
        }
        
        // Lineweight
        if (spline.Lineweight != Lineweight.ByLayer)
        {
            sb.AppendLine($"            splineEntity.Lineweight = Lineweight.{spline.Lineweight};");
        }
        
        // Linetype scale
        if (Math.Abs(spline.LinetypeScale - 1.0) > 1e-10)
        {
            sb.AppendLine($"            splineEntity.LinetypeScale = {F(spline.LinetypeScale)};");
        }
        
        sb.AppendLine("            doc.Entities.Add(splineEntity);");
        sb.AppendLine("        }");
    }

    private void GenerateSplineConstructor(StringBuilder sb, Spline spline, string indent)
    {
        sb.AppendLine($"{indent}new Spline(");
        sb.AppendLine($"{indent}    new List<Vector3>()");
        sb.AppendLine($"{indent}    {{");
        foreach (var cp in spline.ControlPoints)
        {
            sb.AppendLine($"{indent}        new Vector3({F(cp.X)}, {F(cp.Y)}, {F(cp.Z)}),");
        }
        sb.AppendLine($"{indent}    }},");
        sb.AppendLine($"{indent}    new List<double>()");
        sb.AppendLine($"{indent}    {{");
        foreach (var weight in spline.Weights)
        {
            sb.AppendLine($"{indent}        {F(weight)},");
        }
        sb.AppendLine($"{indent}    }},");
        sb.AppendLine($"{indent}    {spline.Degree})");
    }

    private void GenerateText(StringBuilder sb, Text text)
    {
        sb.AppendLine($"        doc.Entities.Add(new Text(");
        sb.AppendLine($"            \"{Escape(text.Value)}\",");
        sb.AppendLine($"            new Vector3({F(text.Position.X)}, {F(text.Position.Y)}, {F(text.Position.Z)}),");
        sb.AppendLine($"            {F(text.Height)})");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, text);
        if (text.Style?.Name != "Standard")
        {
            sb.AppendLine($"            Style = textStyle{SafeName(text.Style?.Name ?? "Standard")},");
        }
        if (Math.Abs(text.Rotation) > 1e-12)
        {
            sb.AppendLine($"            Rotation = {F(text.Rotation)},");
        }
        sb.AppendLine("        }");
        sb.AppendLine("        );");
    }

    private void GenerateMText(StringBuilder sb, MText mtext)
    {
        sb.AppendLine($"        doc.Entities.Add(new MText(");
        sb.AppendLine($"            \"{EscapeMText(mtext.Value)}\",");
        sb.AppendLine($"            new Vector3({F(mtext.Position.X)}, {F(mtext.Position.Y)}, {F(mtext.Position.Z)}),");
        sb.AppendLine($"            {F(mtext.Height)})");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, mtext);
        if (mtext.Style?.Name != "Standard")
        {
            sb.AppendLine($"            Style = textStyle{SafeName(mtext.Style?.Name ?? "Standard")},");
        }
        if (mtext.RectangleWidth > 0)
        {
            sb.AppendLine($"            RectangleWidth = {F(mtext.RectangleWidth)},");
        }
        sb.AppendLine("        }");
        sb.AppendLine("        );");
    }

    private void GenerateEllipse(StringBuilder sb, Ellipse ellipse)
    {
        sb.AppendLine("        doc.Entities.Add(");
        GenerateEllipseConstructor(sb, ellipse, "        ");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, ellipse);
        if (Math.Abs(ellipse.StartAngle) > 1e-12 || Math.Abs(ellipse.EndAngle - 360) > 1e-12)
        {
            sb.AppendLine($"            StartAngle = {F(ellipse.StartAngle)},");
            sb.AppendLine($"            EndAngle = {F(ellipse.EndAngle)},");
        }
        sb.AppendLine("        }");
        sb.AppendLine("        );");
    }

    private void GenerateEllipseConstructor(StringBuilder sb, Ellipse ellipse, string indent)
    {
        sb.AppendLine($"{indent}new Ellipse(");
        sb.AppendLine($"{indent}    new Vector3({F(ellipse.Center.X)}, {F(ellipse.Center.Y)}, {F(ellipse.Center.Z)}),");
        sb.AppendLine($"{indent}    {F(ellipse.MajorAxis)}, {F(ellipse.MinorAxis)})");
    }

    private void GenerateEntityProperties(StringBuilder sb, EntityObject entity)
    {
        sb.AppendLine("        {");

        // Layer
        if (entity.Layer != null && _usedLayers.Contains(entity.Layer.Name))
        {
            sb.AppendLine($"            Layer = layer{SafeName(entity.Layer.Name)},");
        }

        // Color (if not ByLayer)
        if (entity.Color.Index != 256) // 256 = ByLayer
        {
            if (entity.Color.Index == 0)
                sb.AppendLine("            Color = AciColor.ByBlock,");
            else if (entity.Color.Index >= 1 && entity.Color.Index <= 255)
                sb.AppendLine($"            Color = new AciColor({entity.Color.Index}),");
            // Note: TrueColor emission omitted to avoid API differences across versions
        }

        // Linetype
        if (entity.Linetype != null && entity.Linetype.Name != "ByLayer" && entity.Linetype.Name != "Continuous")
        {
            sb.AppendLine($"            Linetype = linetype{SafeName(entity.Linetype.Name)},");
        }

        // Lineweight
        if (entity.Lineweight != Lineweight.ByLayer)
        {
            sb.AppendLine($"            Lineweight = Lineweight.{entity.Lineweight},");
        }

        // Linetype scale
        if (Math.Abs(entity.LinetypeScale - 1.0) > 1e-10)
        {
            sb.AppendLine($"            LinetypeScale = {F(entity.LinetypeScale)},");
        }

        // Thickness (only for entities that support it in netDxf 3.0.1)
        if (entity is Line line && Math.Abs(line.Thickness) > 1e-10)
        {
            sb.AppendLine($"            Thickness = {F(line.Thickness)},");
        }
        else if (entity is Arc arc && Math.Abs(arc.Thickness) > 1e-10)
        {
            sb.AppendLine($"            Thickness = {F(arc.Thickness)},");
        }
        else if (entity is Circle circle && Math.Abs(circle.Thickness) > 1e-10)
        {
            sb.AppendLine($"            Thickness = {F(circle.Thickness)},");
        }
        else if (entity is Polyline2D poly2d && Math.Abs(poly2d.Thickness) > 1e-10)
        {
            sb.AppendLine($"            Thickness = {F(poly2d.Thickness)},");
        }
        else if (entity is Solid solid && Math.Abs(solid.Thickness) > 1e-10)
        {
            sb.AppendLine($"            Thickness = {F(solid.Thickness)},");
        }

        // Normal (if not default 0,0,1)
        var n = entity.Normal;
        if (Math.Abs(n.X) > 1e-12 || Math.Abs(n.Y) > 1e-12 || Math.Abs(n.Z - 1.0) > 1e-12)
        {
            sb.AppendLine($"            Normal = new Vector3({F(n.X)}, {F(n.Y)}, {F(n.Z)}),");
        }

        sb.AppendLine("        }");
    }

    private void GenerateEntityPropertiesCore(StringBuilder sb, EntityObject entity)
    {
        // Layer
        if (entity.Layer != null && _usedLayers.Contains(entity.Layer.Name))
        {
            sb.AppendLine($"            Layer = layer{SafeName(entity.Layer.Name)},");
        }

        // Color (if not ByLayer)
        if (entity.Color.Index != 256) // 256 = ByLayer
        {
            if (entity.Color.Index == 0)
                sb.AppendLine("            Color = AciColor.ByBlock,");
            else if (entity.Color.Index >= 1 && entity.Color.Index <= 255)
                sb.AppendLine($"            Color = new AciColor({entity.Color.Index}),");
            // Note: TrueColor emission omitted to avoid API differences across versions
        }

        // Linetype
        if (entity.Linetype != null && entity.Linetype.Name != "ByLayer" && entity.Linetype.Name != "Continuous")
        {
            sb.AppendLine($"            Linetype = linetype{SafeName(entity.Linetype.Name)},");
        }

        // Lineweight
        if (entity.Lineweight != Lineweight.ByLayer)
        {
            sb.AppendLine($"            Lineweight = Lineweight.{entity.Lineweight},");
        }

        // Linetype scale
        if (Math.Abs(entity.LinetypeScale - 1.0) > 1e-10)
        {
            sb.AppendLine($"            LinetypeScale = {F(entity.LinetypeScale)},");
        }

        // Thickness (only for entities that support it in netDxf 3.0.1)
        if (entity is Line line && Math.Abs(line.Thickness) > 1e-10)
        {
            sb.AppendLine($"            Thickness = {F(line.Thickness)},");
        }
        else if (entity is Arc arc && Math.Abs(arc.Thickness) > 1e-10)
        {
            sb.AppendLine($"            Thickness = {F(arc.Thickness)},");
        }
        else if (entity is Circle circle && Math.Abs(circle.Thickness) > 1e-10)
        {
            sb.AppendLine($"            Thickness = {F(circle.Thickness)},");
        }
        else if (entity is Polyline2D poly2d && Math.Abs(poly2d.Thickness) > 1e-10)
        {
            sb.AppendLine($"            Thickness = {F(poly2d.Thickness)},");
        }

        // Normal (if not default 0,0,1)
        var n = entity.Normal;
        if (Math.Abs(n.X) > 1e-12 || Math.Abs(n.Y) > 1e-12 || Math.Abs(n.Z - 1.0) > 1e-12)
        {
            sb.AppendLine($"            Normal = new Vector3({F(n.X)}, {F(n.Y)}, {F(n.Z)}),");
        }
    }

    private void GenerateBlockEntity(StringBuilder sb, EntityObject entity, string blockName, DxfCodeGenerationOptions options)
    {
        // Reuse existing entity generation methods by temporarily modifying the output
        var tempSb = new StringBuilder();
        GenerateEntity(tempSb, entity, options);
        
        // Replace "doc.Entities.Add(" with "block{blockName}.Entities.Add("
        var entityCode = tempSb.ToString();
        var modifiedCode = entityCode.Replace("doc.Entities.Add(", $"block{SafeName(blockName)}.Entities.Add(");
        
        sb.Append(modifiedCode);
    }

    private void GenerateInsert(StringBuilder sb, Insert insert)
    {
        var blkName = insert.Block?.Name;
        if (string.IsNullOrEmpty(blkName))
        {
            sb.AppendLine("        // Insert with null block skipped");
            return;
        }
        var safeBlk = SafeName(blkName!);
        var insertVarName = $"ins_{safeBlk}_{_insertCounter++}";
        sb.AppendLine($"        var {insertVarName} = new Insert(block{safeBlk})");
        sb.AppendLine("        {");
        sb.AppendLine($"            Position = new Vector3({F(insert.Position.X)}, {F(insert.Position.Y)}, {F(insert.Position.Z)}),");
        if (Math.Abs(insert.Scale.X - 1.0) > 1e-12 || Math.Abs(insert.Scale.Y - 1.0) > 1e-12 || Math.Abs(insert.Scale.Z - 1.0) > 1e-12)
            sb.AppendLine($"            Scale = new Vector3({F(insert.Scale.X)}, {F(insert.Scale.Y)}, {F(insert.Scale.Z)}),");
        if (Math.Abs(insert.Rotation) > 1e-12)
            sb.AppendLine($"            Rotation = {F(insert.Rotation)},");
        if (insert.Layer != null && _usedLayers.Contains(insert.Layer.Name))
            sb.AppendLine($"            Layer = layer{SafeName(insert.Layer.Name)},");
        sb.AppendLine("        };");

        // Attributes
        if (insert.Attributes != null && insert.Attributes.Count > 0)
        {
            foreach (var att in insert.Attributes)
            {
                // Assign value by tag when possible
                if (!string.IsNullOrEmpty(att.Tag))
                {
                    sb.AppendLine($"        var attr_{SafeName(att.Tag)} = {insertVarName}.Attributes.AttributeWithTag(\"{Escape(att.Tag)}\");");
                    sb.AppendLine($"        if (attr_{SafeName(att.Tag)} != null) attr_{SafeName(att.Tag)}.Value = \"{Escape(att.Value)}\";");
                }
            }
        }

        sb.AppendLine($"        doc.Entities.Add({insertVarName});");
        sb.AppendLine();
    }

    private static string Escape(string s) => s.Replace("\\", "\\\\").Replace("\"", "\\\"");
    
    private static string EscapeMText(string s) => s.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\n", "\\P");
    
    private static string SafeName(string name)
    {
        // Convert layer/table names to safe C# identifiers
        var result = new StringBuilder();
        foreach (char c in name)
        {
            if (char.IsLetterOrDigit(c))
                result.Append(c);
            else
                result.Append('_');
        }
        var safeName = result.ToString();
        if (char.IsDigit(safeName[0]))
            safeName = "_" + safeName;
        return safeName;
    }

    private void GenerateHatch(StringBuilder sb, Hatch hatch, DxfCodeGenerationOptions options)
    {
        // Generate Hatch with boundary paths reconstruction
        var patternName = hatch.Pattern?.Name ?? "SOLID";
        var isSolid = string.Equals(patternName, "SOLID", StringComparison.OrdinalIgnoreCase) || string.Equals(patternName, "Solid", StringComparison.OrdinalIgnoreCase);
        
        sb.AppendLine("        {");
        sb.AppendLine("            // Hatch with boundary paths");
        sb.AppendLine("            var boundaryPaths = new List<HatchBoundaryPath>();");
        
        // Reconstruct boundary paths from existing hatch boundary paths
        if (hatch.BoundaryPaths != null && hatch.BoundaryPaths.Count > 0)
        {
            for (int i = 0; i < hatch.BoundaryPaths.Count; i++)
            {
                var path = hatch.BoundaryPaths[i];
                sb.AppendLine($"            // Boundary path {i + 1}");
                sb.AppendLine($"            var pathEntities{i} = new List<EntityObject>();");
                
                // Extract entities from the boundary path edges
                if (path.Edges.Count > 0)
                {
                    foreach (var edge in path.Edges)
                    {
                        var entityObj = edge.ConvertTo();
                        if (entityObj != null)
                        {
                            GenerateBoundaryEntity(sb, entityObj, options, i);
                        }
                    }
                }
                
                sb.AppendLine($"            boundaryPaths.Add(new HatchBoundaryPath(pathEntities{i}));");
                sb.AppendLine();
            }
        }
        
        // Create the hatch with the pattern and boundaries
        if (isSolid)
        {
            sb.AppendLine("            var hatchEntity = new Hatch(HatchPattern.Solid, boundaryPaths, false);");
        }
        else
        {
            sb.AppendLine($"            var hatchEntity = new Hatch(new HatchPattern(\"{Escape(patternName)}\"), boundaryPaths, false);");
        }
        
        sb.AppendLine($"            hatchEntity.Elevation = {F(hatch.Elevation)};");
        
        // Apply entity properties
        if (hatch.Layer != null && _usedLayers.Contains(hatch.Layer.Name))
        {
            sb.AppendLine($"            hatchEntity.Layer = layer{SafeName(hatch.Layer.Name)};");
        }
        
        // Color handling
        if (hatch.Color.Index != 256) // Not ByLayer
        {
            if (hatch.Color.Index == 0)
                sb.AppendLine("            hatchEntity.Color = AciColor.ByBlock;");
            else
                sb.AppendLine($"            hatchEntity.Color = new AciColor({hatch.Color.Index});");
        }
        
        sb.AppendLine("            doc.Entities.Add(hatchEntity);");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private void GenerateBoundaryEntity(StringBuilder sb, EntityObject entity, DxfCodeGenerationOptions options, int pathIndex)
    {
        // Generate entity creation code for boundary paths without properties
        sb.AppendLine($"            pathEntities{pathIndex}.Add(");
        
        switch (entity)
        {
            case Line line:
                GenerateLineConstructor(sb, line, "            ");
                break;
            case Arc arc:
                GenerateArcConstructor(sb, arc, "            ");
                break;
            case Circle circle:
                GenerateCircleConstructor(sb, circle, "            ");
                break;
            case Polyline2D poly2d:
                GeneratePolyline2DConstructor(sb, poly2d, "            ");
                break;
            case Ellipse ellipse:
                GenerateEllipseConstructor(sb, ellipse, "            ");
                break;
            case Spline spline:
                GenerateSplineConstructor(sb, spline, "            ");
                break;
            default:
                // Fallback for other entity types
                sb.AppendLine($"            // Unsupported boundary entity type: {entity.GetType().Name}");
                sb.AppendLine("            null");
                break;
        }
        
        sb.AppendLine("            );");
    }

    private void GenerateWipeout(StringBuilder sb, Wipeout wipeout)
    {
        sb.AppendLine("        {");
        sb.AppendLine("            // Wipeout entity with clipping boundary");
        sb.AppendLine("            var boundaryVertices = new List<Vector2>();");
        
        if (wipeout.ClippingBoundary != null && wipeout.ClippingBoundary.Vertexes.Count > 0)
        {
            foreach (var vertex in wipeout.ClippingBoundary.Vertexes)
            {
                sb.AppendLine($"            boundaryVertices.Add(new Vector2({F(vertex.X)}, {F(vertex.Y)}));");
            }
        }
        
        sb.AppendLine("            var wipeoutEntity = new Wipeout(boundaryVertices);");
        
        // Apply entity properties
        if (wipeout.Layer != null && _usedLayers.Contains(wipeout.Layer.Name))
        {
            sb.AppendLine($"            wipeoutEntity.Layer = layer{SafeName(wipeout.Layer.Name)};");
        }
        
        sb.AppendLine("            doc.Entities.Add(wipeoutEntity);");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private void GenerateLeader(StringBuilder sb, Leader leader)
    {
        sb.AppendLine("        {");
        sb.AppendLine("            // Leader entity with vertices");
        sb.AppendLine("            var leaderVertices = new List<Vector2>();");
        
        if (leader.Vertexes != null && leader.Vertexes.Count > 0)
        {
            foreach (var vertex in leader.Vertexes)
            {
                sb.AppendLine($"            leaderVertices.Add(new Vector2({F(vertex.X)}, {F(vertex.Y)}));");
            }
        }
        
        sb.AppendLine("            var leaderEntity = new Leader(leaderVertices);");
        
        // Apply entity properties
        if (leader.Layer != null && _usedLayers.Contains(leader.Layer.Name))
        {
            sb.AppendLine($"            leaderEntity.Layer = layer{SafeName(leader.Layer.Name)};");
        }
        
        // Color handling
        if (leader.Color.Index != 256) // Not ByLayer
        {
            if (leader.Color.Index == 0)
                sb.AppendLine("            leaderEntity.Color = AciColor.ByBlock;");
            else
                sb.AppendLine($"            leaderEntity.Color = new AciColor({leader.Color.Index});");
        }
        
        sb.AppendLine("            doc.Entities.Add(leaderEntity);");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private void GenerateFace3D(StringBuilder sb, Face3D face3d)
    {
        sb.AppendLine($"        doc.Entities.Add(new Face3D(");
        sb.AppendLine($"            new Vector3({F(face3d.FirstVertex.X)}, {F(face3d.FirstVertex.Y)}, {F(face3d.FirstVertex.Z)}),");
        sb.AppendLine($"            new Vector3({F(face3d.SecondVertex.X)}, {F(face3d.SecondVertex.Y)}, {F(face3d.SecondVertex.Z)}),");
        sb.AppendLine($"            new Vector3({F(face3d.ThirdVertex.X)}, {F(face3d.ThirdVertex.Y)}, {F(face3d.ThirdVertex.Z)}),");
        sb.AppendLine($"            new Vector3({F(face3d.FourthVertex.X)}, {F(face3d.FourthVertex.Y)}, {F(face3d.FourthVertex.Z)}))");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, face3d);
        
        // EdgeFlags
        if (face3d.EdgeFlags != Face3DEdgeFlags.None)
        {
            var edgeFlagsStr = GenerateEnumFlags(face3d.EdgeFlags);
            sb.AppendLine($"            EdgeFlags = {edgeFlagsStr},");
        }
        
        sb.AppendLine("        }");
        sb.AppendLine("        );");
    }

    private void GenerateLinearDimension(StringBuilder sb, LinearDimension dimension)
    {
        sb.AppendLine($"        doc.Entities.Add(new LinearDimension(");
        sb.AppendLine($"            new Vector2({F(dimension.FirstReferencePoint.X)}, {F(dimension.FirstReferencePoint.Y)}),");
        sb.AppendLine($"            new Vector2({F(dimension.SecondReferencePoint.X)}, {F(dimension.SecondReferencePoint.Y)}),");
        sb.AppendLine($"            {F(dimension.Offset)}, {F(dimension.Rotation)})");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, dimension);
        sb.AppendLine("        }");
        sb.AppendLine("        );");
    }

    private void GenerateAlignedDimension(StringBuilder sb, AlignedDimension dimension)
    {
        sb.AppendLine($"        doc.Entities.Add(new AlignedDimension(");
        sb.AppendLine($"            new Vector2({F(dimension.FirstReferencePoint.X)}, {F(dimension.FirstReferencePoint.Y)}),");
        sb.AppendLine($"            new Vector2({F(dimension.SecondReferencePoint.X)}, {F(dimension.SecondReferencePoint.Y)}),");
        sb.AppendLine($"            {F(dimension.Offset)})");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, dimension);
        sb.AppendLine("        }");
        sb.AppendLine("        );");
    }

    private void GenerateRadialDimension(StringBuilder sb, RadialDimension dimension)
    {
        sb.AppendLine($"        doc.Entities.Add(new RadialDimension(");
        sb.AppendLine($"            new Vector2({F(dimension.CenterPoint.X)}, {F(dimension.CenterPoint.Y)}),");
        sb.AppendLine($"            new Vector2({F(dimension.ReferencePoint.X)}, {F(dimension.ReferencePoint.Y)})");
        sb.AppendLine($"        )");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, dimension);
        sb.AppendLine("        }");
        sb.AppendLine("        );");
    }

    private void GenerateDiametricDimension(StringBuilder sb, DiametricDimension dimension)
    {
        sb.AppendLine($"        doc.Entities.Add(new DiametricDimension(");
        sb.AppendLine($"            new Vector2({F(dimension.CenterPoint.X)}, {F(dimension.CenterPoint.Y)}),");
        sb.AppendLine($"            new Vector2({F(dimension.ReferencePoint.X)}, {F(dimension.ReferencePoint.Y)})");
        sb.AppendLine($"        )");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, dimension);
        sb.AppendLine("        }");
        sb.AppendLine("        );");
    }

    private void GenerateAngular2LineDimension(StringBuilder sb, Angular2LineDimension dimension)
    {
        sb.AppendLine($"        doc.Entities.Add(new Angular2LineDimension(");
        sb.AppendLine($"            new Vector2({F(dimension.StartFirstLine.X)}, {F(dimension.StartFirstLine.Y)}),");
        sb.AppendLine($"            new Vector2({F(dimension.EndFirstLine.X)}, {F(dimension.EndFirstLine.Y)}),");
        sb.AppendLine($"            new Vector2({F(dimension.StartSecondLine.X)}, {F(dimension.StartSecondLine.Y)}),");
        sb.AppendLine($"            new Vector2({F(dimension.EndSecondLine.X)}, {F(dimension.EndSecondLine.Y)}),");
        sb.AppendLine($"            {F(dimension.Offset)})");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, dimension);
        sb.AppendLine("        }");
        sb.AppendLine("        );");
    }

    private void GenerateAngular3PointDimension(StringBuilder sb, Angular3PointDimension dimension)
    {
        sb.AppendLine($"        doc.Entities.Add(new Angular3PointDimension(");
        sb.AppendLine($"            new Vector2({F(dimension.CenterPoint.X)}, {F(dimension.CenterPoint.Y)}),");
        sb.AppendLine($"            new Vector2({F(dimension.StartPoint.X)}, {F(dimension.StartPoint.Y)}),");
        sb.AppendLine($"            new Vector2({F(dimension.EndPoint.X)}, {F(dimension.EndPoint.Y)}),");
        sb.AppendLine($"            {F(dimension.Offset)})");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, dimension);
        sb.AppendLine("        }");
        sb.AppendLine("        );");
    }

    private void GenerateOrdinateDimension(StringBuilder sb, OrdinateDimension dimension)
    {
        sb.AppendLine($"        doc.Entities.Add(new OrdinateDimension(");
        sb.AppendLine($"            Vector2.Zero,");
        sb.AppendLine($"            new Vector2({F(dimension.FeaturePoint.X)}, {F(dimension.FeaturePoint.Y)}),");
        sb.AppendLine($"            new Vector2({F(dimension.LeaderEndPoint.X)}, {F(dimension.LeaderEndPoint.Y)}),");
        sb.AppendLine($"            OrdinateDimensionAxis.{dimension.Axis})");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, dimension);
        sb.AppendLine("        }");
        sb.AppendLine("        );");
    }

    private void GenerateRay(StringBuilder sb, Ray ray)
    {
        sb.AppendLine($"        doc.Entities.Add(new Ray(");
        sb.AppendLine($"            new Vector3({F(ray.Origin.X)}, {F(ray.Origin.Y)}, {F(ray.Origin.Z)}),");
        sb.AppendLine($"            new Vector3({F(ray.Direction.X)}, {F(ray.Direction.Y)}, {F(ray.Direction.Z)})");
        sb.AppendLine("        )");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, ray);
        sb.AppendLine("        }");
        sb.AppendLine("        );");
    }

    private void GenerateXLine(StringBuilder sb, XLine xline)
    {
        sb.AppendLine($"        doc.Entities.Add(new XLine(");
        sb.AppendLine($"            new Vector3({F(xline.Origin.X)}, {F(xline.Origin.Y)}, {F(xline.Origin.Z)}),");
        sb.AppendLine($"            new Vector3({F(xline.Direction.X)}, {F(xline.Direction.Y)}, {F(xline.Direction.Z)}))");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, xline);
        sb.AppendLine("        }");
        sb.AppendLine("        );");
    }

    private void GenerateSolid(StringBuilder sb, Solid solid)
    {
        sb.AppendLine($"        doc.Entities.Add(new Solid(");
        sb.AppendLine($"            new Vector2({F(solid.FirstVertex.X)}, {F(solid.FirstVertex.Y)}),");
        sb.AppendLine($"            new Vector2({F(solid.SecondVertex.X)}, {F(solid.SecondVertex.Y)}),");
        sb.AppendLine($"            new Vector2({F(solid.ThirdVertex.X)}, {F(solid.ThirdVertex.Y)}),");
        sb.AppendLine($"            new Vector2({F(solid.FourthVertex.X)}, {F(solid.FourthVertex.Y)}))");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, solid);
        if (Math.Abs(solid.Thickness) > 1e-10)
        {
            sb.AppendLine($"            Thickness = {F(solid.Thickness)},");
        }
        sb.AppendLine("        }");
        sb.AppendLine("        );");
    }

    private void GenerateMLine(StringBuilder sb, MLine mline)
    {
        sb.AppendLine("        {");
        sb.AppendLine("            // MLine entity with vertices");
        sb.AppendLine("            var mlineVertices = new List<Vector2>();");
        
        if (mline.Vertexes != null && mline.Vertexes.Count > 0)
        {
            foreach (var vertex in mline.Vertexes)
            {
                sb.AppendLine($"            mlineVertices.Add(new Vector2({F(vertex.Position.X)}, {F(vertex.Position.Y)}));");
            }
        }
        
        sb.AppendLine("            var mlineEntity = new MLine(mlineVertices);");
        
        // Apply entity properties
        if (mline.Layer != null && _usedLayers.Contains(mline.Layer.Name))
        {
            sb.AppendLine($"            mlineEntity.Layer = layer{SafeName(mline.Layer.Name)};");
        }
        
        // Color handling
        if (mline.Color.Index != 256) // Not ByLayer
        {
            if (mline.Color.Index == 0)
                sb.AppendLine("            mlineEntity.Color = AciColor.ByBlock;");
            else
                sb.AppendLine($"            mlineEntity.Color = new AciColor({mline.Color.Index});");
        }
        
        sb.AppendLine("            doc.Entities.Add(mlineEntity);");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private void GenerateImage(StringBuilder sb, Image image)
    {
        sb.AppendLine("        {");
        sb.AppendLine($"            var imageDefinition = new ImageDefinition(\"{image.Definition.Name}\", {image.Definition.Width}, {F(image.Definition.HorizontalResolution)}, {image.Definition.Height}, {F(image.Definition.VerticalResolution)}, ImageResolutionUnits.{image.Definition.ResolutionUnits});");
        sb.AppendLine($"            var imageEntity = new Image(imageDefinition,");
        sb.AppendLine($"                new Vector3({F(image.Position.X)}, {F(image.Position.Y)}, {F(image.Position.Z)}),");
        sb.AppendLine($"                {F(image.Width)}, {F(image.Height)});");
        
        // Apply entity properties
        if (image.Layer != null && _usedLayers.Contains(image.Layer.Name))
        {
            sb.AppendLine($"            imageEntity.Layer = layer{SafeName(image.Layer.Name)};");
        }
        
        // Color handling
        if (image.Color.Index != 256) // Not ByLayer
        {
            if (image.Color.Index == 0)
                sb.AppendLine("            imageEntity.Color = AciColor.ByBlock;");
            else
                sb.AppendLine($"            imageEntity.Color = new AciColor({image.Color.Index});");
        }
        
        // Image-specific properties
        if (image.Rotation != 0)
        {
            sb.AppendLine($"            imageEntity.Rotation = {F(image.Rotation)};");
        }
        if (image.Brightness != 50) // Default brightness is 50
        {
            sb.AppendLine($"            imageEntity.Brightness = {image.Brightness};");
        }
        if (image.Contrast != 50) // Default contrast is 50
        {
            sb.AppendLine($"            imageEntity.Contrast = {image.Contrast};");
        }
        if (image.Fade != 0) // Default fade is 0
        {
            sb.AppendLine($"            imageEntity.Fade = {image.Fade};");
        }
        
        // ClippingBoundary
        if (image.ClippingBoundary != null && image.ClippingBoundary.Vertexes.Count > 0)
        {
            if (image.ClippingBoundary.Type == ClippingBoundaryType.Rectangular && image.ClippingBoundary.Vertexes.Count == 2)
            {
                // Rectangular boundary with two opposite corners
                var firstCorner = image.ClippingBoundary.Vertexes[0];
                var secondCorner = image.ClippingBoundary.Vertexes[1];
                sb.AppendLine($"            imageEntity.ClippingBoundary = new ClippingBoundary(new Vector2({F(firstCorner.X)}, {F(firstCorner.Y)}), new Vector2({F(secondCorner.X)}, {F(secondCorner.Y)}));");
            }
            else
            {
                // Polygonal boundary with 3 or more vertices
                sb.AppendLine("            var clippingVertices = new List<Vector2>");
                sb.AppendLine("            {");
                for (int i = 0; i < image.ClippingBoundary.Vertexes.Count; i++)
                {
                    var vertex = image.ClippingBoundary.Vertexes[i];
                    var comma = i < image.ClippingBoundary.Vertexes.Count - 1 ? "," : "";
                    sb.AppendLine($"                new Vector2({F(vertex.X)}, {F(vertex.Y)}){comma}");
                }
                sb.AppendLine("            };");
                sb.AppendLine("            imageEntity.ClippingBoundary = new ClippingBoundary(clippingVertices);");
            }
        }
        
        sb.AppendLine("            doc.Entities.Add(imageEntity);");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private void GenerateMesh(StringBuilder sb, Mesh mesh)
    {
        sb.AppendLine("        var meshVertexes = new List<Vector3>");
        sb.AppendLine("        {");
        for (int i = 0; i < mesh.Vertexes.Count; i++)
        {
            var vertex = mesh.Vertexes[i];
            sb.AppendLine($"            new Vector3({F(vertex.X)}, {F(vertex.Y)}, {F(vertex.Z)}){(i < mesh.Vertexes.Count - 1 ? "," : "")}");
        }
        sb.AppendLine("        };");
        sb.AppendLine();
        
        sb.AppendLine("        var meshFaces = new List<int[]>");
        sb.AppendLine("        {");
        for (int i = 0; i < mesh.Faces.Count; i++)
        {
            var face = mesh.Faces[i];
            sb.Append("            new int[] { ");
            for (int j = 0; j < face.Length; j++)
            {
                sb.Append(face[j]);
                if (j < face.Length - 1) sb.Append(", ");
            }
            sb.AppendLine($" }}{(i < mesh.Faces.Count - 1 ? "," : "")}");
        }
        sb.AppendLine("        };");
        sb.AppendLine();
        
        // Generate mesh edges if they exist
        if (mesh.Edges != null && mesh.Edges.Count > 0)
        {
            sb.AppendLine("        var meshEdges = new List<MeshEdge>");
            sb.AppendLine("        {");
            for (int i = 0; i < mesh.Edges.Count; i++)
            {
                var edge = mesh.Edges[i];
                sb.AppendLine($"            new MeshEdge({edge.StartVertexIndex}, {edge.EndVertexIndex}){(i < mesh.Edges.Count - 1 ? "," : "")}");
            }
            sb.AppendLine("        };");
            sb.AppendLine();
            
            sb.AppendLine("        var mesh = new Mesh(meshVertexes, meshFaces, meshEdges)");
        }
        else
        {
            sb.AppendLine("        var mesh = new Mesh(meshVertexes, meshFaces)");
        }
        
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, mesh);
        sb.AppendLine($"            SubdivisionLevel = {mesh.SubdivisionLevel}");
        sb.AppendLine("        };");
        sb.AppendLine("        doc.Entities.Add(mesh);");
    }

    private void GeneratePolyfaceMesh(StringBuilder sb, PolyfaceMesh polyfaceMesh)
    {
        sb.AppendLine("        // Generate PolyfaceMesh vertexes");
        sb.AppendLine("        var polyfaceMeshVertexes = new Vector3[]");
        sb.AppendLine("        {");
        for (int i = 0; i < polyfaceMesh.Vertexes.Length; i++)
        {
            var vertex = polyfaceMesh.Vertexes[i];
            string comma = i < polyfaceMesh.Vertexes.Length - 1 ? "," : "";
            sb.AppendLine($"            new Vector3({F(vertex.X)}, {F(vertex.Y)}, {F(vertex.Z)}){comma}");
        }
        sb.AppendLine("        };");
        sb.AppendLine();
        
        sb.AppendLine("        // Generate PolyfaceMesh faces");
        sb.AppendLine("        var polyfaceMeshFaces = new PolyfaceMeshFace[]");
        sb.AppendLine("        {");
        for (int i = 0; i < polyfaceMesh.Faces.Count; i++)
        {
            var face = polyfaceMesh.Faces[i];
            string comma = i < polyfaceMesh.Faces.Count - 1 ? "," : "";
            string vertexIndexes = string.Join(", ", face.VertexIndexes);
            sb.AppendLine($"            new PolyfaceMeshFace(new short[] {{ {vertexIndexes} }}){comma}");
        }
        sb.AppendLine("        };");
        sb.AppendLine();
        
        sb.AppendLine("        var polyfaceMesh = new PolyfaceMesh(polyfaceMeshVertexes, polyfaceMeshFaces)");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, polyfaceMesh);
        sb.AppendLine("        };");
        sb.AppendLine("        doc.Entities.Add(polyfaceMesh);");
        sb.AppendLine();
    }

    private void GeneratePolygonMesh(StringBuilder sb, PolygonMesh polygonMesh)
    {
        sb.AppendLine("        // Generate PolygonMesh vertexes");
        sb.AppendLine("        var polygonMeshVertexes = new Vector3[]");
        sb.AppendLine("        {");
        for (int i = 0; i < polygonMesh.Vertexes.Length; i++)
        {
            var vertex = polygonMesh.Vertexes[i];
            string comma = i < polygonMesh.Vertexes.Length - 1 ? "," : "";
            sb.AppendLine($"            new Vector3({F(vertex.X)}, {F(vertex.Y)}, {F(vertex.Z)}){comma}");
        }
        sb.AppendLine("        };");
        sb.AppendLine();
        
        sb.AppendLine($"        var polygonMesh = new PolygonMesh({polygonMesh.U}, {polygonMesh.V}, polygonMeshVertexes)");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, polygonMesh);
        // Ensure DensityU and DensityV are within valid range (3-201)
        var densityU = (short)Math.Max(3, Math.Min(201, (int)polygonMesh.DensityU));
        var densityV = (short)Math.Max(3, Math.Min(201, (int)polygonMesh.DensityV));
        sb.AppendLine($"            DensityU = {densityU},");
        sb.AppendLine($"            DensityV = {densityV},");
        sb.AppendLine($"            SmoothType = PolylineSmoothType.{polygonMesh.SmoothType},");
        sb.AppendLine($"            IsClosedInU = {polygonMesh.IsClosedInU.ToString().ToLower()},");
        sb.AppendLine($"            IsClosedInV = {polygonMesh.IsClosedInV.ToString().ToLower()}");
        sb.AppendLine("        };");
        sb.AppendLine("        doc.Entities.Add(polygonMesh);");
        sb.AppendLine();
    }

    private void GenerateShape(StringBuilder sb, Shape shape)
    {
        sb.AppendLine($"        doc.Entities.Add(new Shape(\"{shape.Name}\",");
        sb.AppendLine($"            new ShapeStyle(\"{shape.Style.Name}\", \"{shape.Style.File}\"),");
        sb.AppendLine($"            new Vector3({F(shape.Position.X)}, {F(shape.Position.Y)}, {F(shape.Position.Z)}),");
        sb.AppendLine($"            {F(shape.Size)}, {F(shape.Rotation)})");
        sb.AppendLine($"        {{");
        GenerateEntityPropertiesCore(sb, shape);
        sb.AppendLine($"        }});");
    }

    private void GenerateTolerance(StringBuilder sb, Tolerance tolerance)
    {
        sb.AppendLine($"        doc.Entities.Add(new Tolerance(");
        sb.AppendLine($"            new ToleranceEntry(),");
        sb.AppendLine($"            new Vector3({F(tolerance.Position.X)}, {F(tolerance.Position.Y)}, {F(tolerance.Position.Z)})");
        sb.AppendLine($"        )");
        sb.AppendLine($"        {{");
        sb.AppendLine($"            TextHeight = {F(tolerance.TextHeight)},");
        sb.AppendLine($"            Rotation = {F(tolerance.Rotation)},");
        GenerateEntityPropertiesCore(sb, tolerance);
        sb.AppendLine($"        }});");
    }

    private void GenerateTrace(StringBuilder sb, Trace trace)
    {
        sb.AppendLine($"        doc.Entities.Add(new Trace(");
        sb.AppendLine($"            new Vector2({F(trace.FirstVertex.X)}, {F(trace.FirstVertex.Y)}),");
        sb.AppendLine($"            new Vector2({F(trace.SecondVertex.X)}, {F(trace.SecondVertex.Y)}),");
        sb.AppendLine($"            new Vector2({F(trace.ThirdVertex.X)}, {F(trace.ThirdVertex.Y)}),");
        sb.AppendLine($"            new Vector2({F(trace.FourthVertex.X)}, {F(trace.FourthVertex.Y)})");
        sb.AppendLine($"        )");
        sb.AppendLine($"        {{");
        GenerateEntityPropertiesCore(sb, trace);
        sb.AppendLine($"        }});");
    }

    private void GenerateUnderlay(StringBuilder sb, Underlay underlay)
    {
        sb.AppendLine("        // Note: Underlay requires UnderlayDefinition to be added to document first");
        sb.AppendLine($"        // Create underlay definition for {underlay.Definition.Type} type");
        // Generate the correct underlay definition class name
        string definitionClassName = underlay.Definition.Type switch
        {
            UnderlayType.DGN => "UnderlayDgnDefinition",
            UnderlayType.DWF => "UnderlayDwfDefinition", 
            UnderlayType.PDF => "UnderlayPdfDefinition",
            _ => $"Underlay{underlay.Definition.Type}Definition"
        };
        sb.AppendLine($"        var underlayDef = new {definitionClassName}(\"{underlay.Definition.Name}\", \"{underlay.Definition.File}\");");
        sb.AppendLine();
        
        sb.AppendLine("        doc.Entities.Add(new Underlay(underlayDef)");
        sb.AppendLine("        {");
        sb.AppendLine($"            Position = new Vector3({F(underlay.Position.X)}, {F(underlay.Position.Y)}, {F(underlay.Position.Z)}),");
            sb.AppendLine($"            Scale = new Vector2({F(underlay.Scale.X)}, {F(underlay.Scale.Y)}),");
            sb.AppendLine($"            Rotation = {F(underlay.Rotation)},");
        sb.AppendLine($"            Contrast = {underlay.Contrast},");
        sb.AppendLine($"            Fade = {underlay.Fade},");
        sb.AppendLine($"            DisplayOptions = UnderlayDisplayFlags.{underlay.DisplayOptions},");
        if (underlay.ClippingBoundary != null)
        {
            sb.AppendLine($"            // ClippingBoundary = clippingBoundary, // Custom clipping boundary implementation needed");
        }
        GenerateEntityPropertiesCore(sb, underlay);
        sb.AppendLine("        });");
        sb.AppendLine();
    }

    private void GenerateViewport(StringBuilder sb, Viewport viewport)
    {
        var statusFlags = GenerateViewportStatusFlags(viewport.Status);
        if (statusFlags.Length > 80) // If the line is too long, use a variable
        {
            sb.AppendLine($"        var viewportStatus = {statusFlags};");
        }
        
        sb.AppendLine($"        doc.Entities.Add(");
        sb.AppendLine($"        new Viewport(");
        sb.AppendLine($"            new Vector2({F(viewport.Center.X)}, {F(viewport.Center.Y)}),");
        sb.AppendLine($"            {F(viewport.Width)}, {F(viewport.Height)})");
        sb.AppendLine($"        {{");
        GenerateEntityPropertiesCore(sb, viewport);
        // Set Center property if Z coordinate is not zero
        if (Math.Abs(viewport.Center.Z) > 1e-6)
        {
            sb.AppendLine($"            Center = new Vector3({F(viewport.Center.X)}, {F(viewport.Center.Y)}, {F(viewport.Center.Z)}),");
        }
        sb.AppendLine($"            ViewCenter = new Vector2({F(viewport.ViewCenter.X)}, {F(viewport.ViewCenter.Y)}),");
        sb.AppendLine($"            ViewHeight = {F(viewport.ViewHeight)},");
        sb.AppendLine($"            ViewTarget = new Vector3({F(viewport.ViewTarget.X)}, {F(viewport.ViewTarget.Y)}, {F(viewport.ViewTarget.Z)}),");
        sb.AppendLine($"            ViewDirection = new Vector3({F(viewport.ViewDirection.X)}, {F(viewport.ViewDirection.Y)}, {F(viewport.ViewDirection.Z)}),");
        sb.AppendLine($"            LensLength = {F(viewport.LensLength)},");
        sb.AppendLine($"            TwistAngle = {F(viewport.TwistAngle)},");
        sb.AppendLine($"            CircleZoomPercent = {viewport.CircleZoomPercent},");
        
        if (statusFlags.Length > 80)
        {
            sb.AppendLine($"            Status = viewportStatus,");
        }
        else
        {
            sb.AppendLine($"            Status = {statusFlags},");
        }
        sb.AppendLine($"        }}");
        sb.AppendLine($"        );");
    }

    private string GenerateViewportStatusFlags(ViewportStatusFlags flags)
    {
        if ((int)flags == 0)
            return "(ViewportStatusFlags)0";

        var flagNames = new List<string>();
        
        foreach (ViewportStatusFlags flag in Enum.GetValues(typeof(ViewportStatusFlags)))
        {
            if ((int)flag != 0 && flags.HasFlag(flag))
            {
                flagNames.Add($"ViewportStatusFlags.{flag}");
            }
        }
        
        return flagNames.Count > 0 ? string.Join(" | ", flagNames) : "(ViewportStatusFlags)0";
    }
}
