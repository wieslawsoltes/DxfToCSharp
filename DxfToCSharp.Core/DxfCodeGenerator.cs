using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Globalization;
using netDxf;
using netDxf.Entities;
using netDxf.Tables;
using netDxf.Header;
using PointEntity = netDxf.Entities.Point;

namespace DxfToCSharp.Core;

public class DxfCodeGenerator
{
    private static string F(double v) => v.ToString("G17", CultureInfo.InvariantCulture);

    private string GenerateEnumFlags<T>(T enumValue) where T : Enum
    {
        var enumType = typeof(T);
        var enumName = enumType.Name;
        var value = Convert.ToInt32(enumValue);
        
        if (value == 0)
        {
            return $"{enumName}.None";
        }
        
        var flags = new List<string>();
        foreach (var enumVal in Enum.GetValues(enumType))
        {
            var intVal = Convert.ToInt32(enumVal);
            if (intVal != 0 && (value & intVal) == intVal)
            {
                flags.Add($"{enumName}.{enumVal}");
            }
        }
        
        return flags.Count > 0 ? string.Join(" | ", flags) : $"{enumName}.None";
    }
    private readonly HashSet<string> _usedLayers = new();
    private readonly HashSet<string> _usedLinetypes = new();
    private readonly HashSet<string> _usedTextStyles = new();
    private readonly HashSet<string> _usedBlocks = new();
    private readonly HashSet<string> _usedDimensionStyles = new();
    private readonly HashSet<string> _usedMLineStyles = new();
    private int _insertCounter = 0;

    public string Generate(DxfDocument doc, string? sourcePath, string? className = null, DxfCodeGenerationOptions? options = null)
    {
        // Use provided options or create default
        options ??= DxfCodeGenerationOptions.CreateDefault();
        
        var allEntities = doc.Entities.All?.ToList() ?? new List<EntityObject>();
        
        // Clear collections for fresh generation
        _usedLayers.Clear();
        _usedLinetypes.Clear();
        _usedTextStyles.Clear();
        _usedBlocks.Clear();
        _usedDimensionStyles.Clear();
        _usedMLineStyles.Clear();
        _insertCounter = 0;

        var sb = new StringBuilder();
        
        // Use provided class name, options class name, or default
        var finalClassName = className ?? options.CustomClassName ?? "DxfDocumentGenerator";
        
        // Header and using statements
        GenerateHeader(sb, sourcePath, options);
        
        // Analyze what tables we need (only if generating any tables)
        if (options.GenerateLayers || options.GenerateLinetypes || options.GenerateTextStyles || 
            options.GenerateBlocks || options.GenerateDimensionStyles || options.GenerateMLineStyles)
        {
            AnalyzeUsedTables(allEntities, options);
        }
        
        // Class definition start
        sb.AppendLine($"public static class {finalClassName}");
        sb.AppendLine("{");
        sb.AppendLine("    public static DxfDocument Create()");
        sb.AppendLine("    {");
        sb.AppendLine("        var doc = new DxfDocument();");
        sb.AppendLine();
        
        // Generate table definitions
        GenerateTableDefinitions(sb, doc, options);
        
        // Generate entities
        if (options.GenerateEntities)
        {
            GenerateEntities(sb, allEntities, options);
        }
        
        // Footer
        sb.AppendLine();
        if (options.GenerateSaveComment)
        {
            sb.AppendLine("        // Save or return the document");
            var saveFileName = !string.IsNullOrEmpty(sourcePath) 
                ? System.IO.Path.GetFileName(sourcePath) 
                : $"{finalClassName.ToLowerInvariant()}.dxf";
            sb.AppendLine($"        // doc.Save(\"{saveFileName}\");");
        }
        if (options.GenerateReturnStatement)
        {
            sb.AppendLine("        return doc;");
        }
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private void GenerateHeader(StringBuilder sb, string? sourcePath, DxfCodeGenerationOptions options)
    {
        if (options.GenerateHeader)
        {
            sb.AppendLine("/// <auto-generated>");
            sb.AppendLine("/// This code was generated by DxfToCSharp.");
            sb.AppendLine("/// </auto-generated>");
            if (!string.IsNullOrEmpty(sourcePath))
                sb.AppendLine($"// Source: {System.IO.Path.GetFileName(sourcePath)}");
            sb.AppendLine($"// Generated: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
            sb.AppendLine();
        }
        
        if (options.GenerateUsingStatements)
        {
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using netDxf;");
            sb.AppendLine("using netDxf.Entities;");
            sb.AppendLine("using netDxf.Tables;");
            sb.AppendLine("using netDxf.Blocks;");
            sb.AppendLine();
        }
    }

    private void AnalyzeUsedTables(List<EntityObject> entities, DxfCodeGenerationOptions options)
    {
        foreach (var entity in entities)
        {
            if (options.GenerateLayers && entity.Layer != null)
                _usedLayers.Add(entity.Layer.Name);
            if (options.GenerateLinetypes && entity.Linetype != null)
                _usedLinetypes.Add(entity.Linetype.Name);
            
            // Check for text entities that use text styles
            if (options.GenerateTextStyles)
            {
                if (entity is Text text && text.Style != null)
                    _usedTextStyles.Add(text.Style.Name);
                else if (entity is MText mtext && mtext.Style != null)
                    _usedTextStyles.Add(mtext.Style.Name);
            }
            
            // Check for Insert entities that use blocks
            if (options.GenerateBlocks && entity is Insert insert && insert.Block != null)
                _usedBlocks.Add(insert.Block.Name);
            
            // Check for Leader entities that use dimension styles
            if (options.GenerateDimensionStyles)
            {
                if (entity is Leader leader && leader.Style != null)
                    _usedDimensionStyles.Add(leader.Style.Name);
                
                // Check for Dimension entities that use dimension styles
                if (entity is Dimension dimension && dimension.Style != null)
                    _usedDimensionStyles.Add(dimension.Style.Name);
            }
            
            // Check for MLine entities that use multiline styles
            if (options.GenerateMLineStyles && entity is MLine mline && mline.Style != null)
                _usedMLineStyles.Add(mline.Style.Name);
        }
    }

    private void GenerateTableDefinitions(StringBuilder sb, DxfDocument doc, DxfCodeGenerationOptions options)
    {
        // Generate layer definitions
        if (options.GenerateLayers && _usedLayers.Count > 0)
        {
            sb.AppendLine("        // Layer definitions");
            foreach (var layerName in _usedLayers.OrderBy(x => x))
            {
                var layer = doc.Layers.FirstOrDefault(l => l.Name == layerName);
                if (layer != null)
                {
                    sb.AppendLine($"        var layer{SafeName(layerName)} = new Layer(\"{Escape(layerName)}\")");
                    sb.AppendLine("        {");
                    if (layer.Color.Index != 7) // Default color is 7 (white)
                        sb.AppendLine($"            Color = new AciColor({layer.Color.Index}),");
                    if (layer.Lineweight != Lineweight.Default)
                        sb.AppendLine($"            Lineweight = Lineweight.{layer.Lineweight},");
                    if (!layer.IsVisible)
                        sb.AppendLine("            IsVisible = false,");
                    if (layer.IsFrozen)
                        sb.AppendLine("            IsFrozen = true,");
                    if (layer.IsLocked)
                        sb.AppendLine("            IsLocked = true,");
                    sb.AppendLine("        };");
                    sb.AppendLine($"        doc.Layers.Add(layer{SafeName(layerName)});");
                    sb.AppendLine();
                }
                else if (layerName == "0")
                {
                    // Handle default layer "0" which might not be in the layers collection
                    sb.AppendLine($"        var layer{SafeName(layerName)} = doc.Layers[\"{layerName}\"];");
                    sb.AppendLine();
                }
            }
        }

        // Generate linetype definitions (if any custom ones)
        if (options.GenerateLinetypes && _usedLinetypes.Any(lt => lt != "Continuous" && lt != "ByLayer" && lt != "ByBlock"))
        {
            sb.AppendLine("        // Linetype definitions");
            foreach (var linetypeName in _usedLinetypes.Where(lt => lt != "Continuous" && lt != "ByLayer" && lt != "ByBlock"))
            {
                var linetype = doc.Linetypes.FirstOrDefault(lt => lt.Name == linetypeName);
                if (linetype != null)
                {
                    sb.AppendLine($"        var linetype{SafeName(linetypeName)} = new Linetype(\"{Escape(linetypeName)}\");");
                    sb.AppendLine($"        doc.Linetypes.Add(linetype{SafeName(linetypeName)});");
                }
            }
            sb.AppendLine();
        }

        // Generate text style definitions (if any custom ones)
        if (options.GenerateTextStyles && _usedTextStyles.Any(ts => ts != "Standard"))
        {
            sb.AppendLine("        // Text style definitions");
            foreach (var styleName in _usedTextStyles.Where(ts => ts != "Standard"))
            {
                var style = doc.TextStyles.FirstOrDefault(ts => ts.Name == styleName);
                if (style != null)
                {
                    // Use the required constructor parameters for TextStyle
                    string fontFile = !string.IsNullOrEmpty(style.FontFile) ? style.FontFile : TextStyle.DefaultFont;
                    sb.AppendLine($"        var textStyle{SafeName(styleName)} = new TextStyle(\"{Escape(styleName)}\", \"{Escape(fontFile)}\");");
                    sb.AppendLine($"        doc.TextStyles.Add(textStyle{SafeName(styleName)});");
                }
            }
            sb.AppendLine();
        }

        // Generate block definitions (if any used)
        if (options.GenerateBlocks && _usedBlocks.Count > 0)
        {
            sb.AppendLine("        // Block definitions");
            foreach (var blockName in _usedBlocks.OrderBy(x => x))
            {
                var block = doc.Blocks.FirstOrDefault(b => b.Name == blockName);
                if (block != null)
                {
                    sb.AppendLine($"        var block{SafeName(blockName)} = new Block(\"{Escape(blockName)}\")");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            Origin = new Vector3({F(block.Origin.X)}, {F(block.Origin.Y)}, {F(block.Origin.Z)}),");
                    if (!string.IsNullOrEmpty(block.Description))
                        sb.AppendLine($"            Description = \"{Escape(block.Description)}\",");
                    if (block.Layer?.Name != "0" && block.Layer != null)
                        sb.AppendLine($"            Layer = new Layer(\"{Escape(block.Layer.Name)}\"),");
                    sb.AppendLine("        };");
                    
                    // Add attribute definitions if any
                    if (block.AttributeDefinitions.Count > 0)
                    {
                        sb.AppendLine("        // Add attribute definitions to block");
                        foreach (var attDef in block.AttributeDefinitions.Values)
                        {
                            sb.AppendLine($"        var attDef{SafeName(blockName)}{SafeName(attDef.Tag)} = new AttributeDefinition(\"{Escape(attDef.Tag)}\")");
                            sb.AppendLine("        {");
                            sb.AppendLine($"            Prompt = \"{Escape(attDef.Prompt)}\",");
                            sb.AppendLine($"            Position = new Vector3({F(attDef.Position.X)}, {F(attDef.Position.Y)}, {F(attDef.Position.Z)}),");
                            sb.AppendLine($"            Height = {F(attDef.Height)},");
                            if (!string.IsNullOrEmpty(attDef.Value))
                                sb.AppendLine($"            Value = \"{Escape(attDef.Value)}\",");
                            if (Math.Abs(attDef.Rotation) > 1e-12)
                                sb.AppendLine($"            Rotation = {F(attDef.Rotation)},");
                            sb.AppendLine("        };");
                            sb.AppendLine($"        block{SafeName(blockName)}.AttributeDefinitions.Add(attDef{SafeName(blockName)}{SafeName(attDef.Tag)});");
                        }
                        sb.AppendLine();
                    }
                    
                    // Add block entities
                    if (block.Entities.Count > 0)
                    {
                        sb.AppendLine("        // Add entities to block");
                        foreach (var entity in block.Entities)
                        {
                            // Generate simplified entity code for block entities
                            GenerateBlockEntity(sb, entity, blockName, options);
                        }
                        sb.AppendLine();
                    }
                    
                    sb.AppendLine($"        doc.Blocks.Add(block{SafeName(blockName)});");
                    sb.AppendLine();
                }
            }
        }
        
        // Generate dimension style definitions (if any custom ones)
        if (options.GenerateDimensionStyles && _usedDimensionStyles.Any(ds => ds != "Standard"))
        {
            sb.AppendLine("        // Dimension style definitions");
            foreach (var styleName in _usedDimensionStyles.Where(ds => ds != "Standard"))
            {
                var style = doc.DimensionStyles.FirstOrDefault(ds => ds.Name == styleName);
                if (style != null)
                {
                    sb.AppendLine($"        var dimStyle{SafeName(styleName)} = new DimensionStyle(\"{Escape(styleName)}\");");
                    sb.AppendLine($"        doc.DimensionStyles.Add(dimStyle{SafeName(styleName)});");
                }
            }
            sb.AppendLine();
        }
        
        // Generate multiline style definitions (if any custom ones)
        if (options.GenerateMLineStyles && _usedMLineStyles.Any(ms => ms != "Standard"))
        {
            sb.AppendLine("        // Multiline style definitions");
            foreach (var styleName in _usedMLineStyles.Where(ms => ms != "Standard"))
            {
                var style = doc.MlineStyles.FirstOrDefault(ms => ms.Name == styleName);
                if (style != null)
                {
                    sb.AppendLine($"        var mlineStyle{SafeName(styleName)} = new MLineStyle(\"{Escape(styleName)}\");");
                    sb.AppendLine($"        doc.MLineStyles.Add(mlineStyle{SafeName(styleName)});");
                }
            }
            sb.AppendLine();
        }
    }

    private void GenerateEntities(StringBuilder sb, List<EntityObject> entities, DxfCodeGenerationOptions options)
    {
        sb.AppendLine("        // Entities");
        
        // Group entities by type if requested
        if (options.GroupEntitiesByType)
        {
            var groupedEntities = entities.GroupBy(e => e.GetType()).OrderBy(g => g.Key.Name);
            foreach (var group in groupedEntities)
            {
                sb.AppendLine($"        // {group.Key.Name} entities");
                foreach (var entity in group)
                {
                    GenerateEntity(sb, entity, options);
                }
                sb.AppendLine();
            }
        }
        else
        {
            foreach (var entity in entities)
            {
                GenerateEntity(sb, entity, options);
            }
        }
    }

    private void GenerateEntity(StringBuilder sb, EntityObject entity, DxfCodeGenerationOptions options)
    {
        if (options.GenerateDetailedComments)
        {
            sb.AppendLine($"        // {entity.GetType().Name}: {entity.Handle}");
        }
        
        switch (entity)
        {
            case Line line when options.GenerateAllEntities || options.GenerateLineEntities:
                GenerateLine(sb, line);
                break;
            case Arc arc when options.GenerateAllEntities || options.GenerateArcEntities:
                GenerateArc(sb, arc);
                break;
            case Circle circle when options.GenerateAllEntities || options.GenerateCircleEntities:
                GenerateCircle(sb, circle);
                break;
            case PointEntity point when options.GenerateAllEntities || options.GeneratePointEntities:
                GeneratePoint(sb, point);
                break;
            case Polyline2D poly2d when options.GenerateAllEntities || options.GeneratePolylineEntities:
                GeneratePolyline2D(sb, poly2d);
                break;
            case Polyline3D poly3d when options.GenerateAllEntities || options.GeneratePolylineEntities:
                GeneratePolyline3D(sb, poly3d);
                break;
            case Spline spline when options.GenerateAllEntities || options.GenerateSplineEntities:
                GenerateSpline(sb, spline);
                break;
            case Text text when options.GenerateAllEntities || options.GenerateTextEntities:
                GenerateText(sb, text);
                break;
            case MText mtext when options.GenerateAllEntities || options.GenerateMTextEntities:
                GenerateMText(sb, mtext);
                break;
            case Ellipse ellipse when options.GenerateAllEntities || options.GenerateEllipseEntities:
                GenerateEllipse(sb, ellipse);
                break;
            case Insert insert when options.GenerateAllEntities || options.GenerateInsertEntities:
                GenerateInsert(sb, insert);
                break;
            case Hatch hatch when options.GenerateAllEntities:
                GenerateHatch(sb, hatch, options);
                break;
            case Wipeout wipeout when options.GenerateAllEntities || options.GenerateWipeoutEntities:
                GenerateWipeout(sb, wipeout);
                break;
            case Leader leader when options.GenerateAllEntities || options.GenerateLeaderEntities:
                GenerateLeader(sb, leader);
                break;
            case Face3D face3d when options.GenerateAllEntities || options.GenerateFace3dEntities:
                GenerateFace3D(sb, face3d);
                break;
            case LinearDimension linearDim when options.GenerateAllEntities || options.GenerateDimensionEntities:
                GenerateLinearDimension(sb, linearDim);
                break;
            case AlignedDimension alignedDim when options.GenerateAllEntities || options.GenerateDimensionEntities:
                GenerateAlignedDimension(sb, alignedDim);
                break;
            case RadialDimension radialDim when options.GenerateAllEntities || options.GenerateDimensionEntities:
                GenerateRadialDimension(sb, radialDim);
                break;
            case DiametricDimension diametricDim when options.GenerateAllEntities || options.GenerateDimensionEntities:
                GenerateDiametricDimension(sb, diametricDim);
                break;
            case Angular2LineDimension angular2LineDim when options.GenerateAllEntities || options.GenerateDimensionEntities:
                GenerateAngular2LineDimension(sb, angular2LineDim);
                break;
            case Angular3PointDimension angular3PointDim when options.GenerateAllEntities || options.GenerateDimensionEntities:
                GenerateAngular3PointDimension(sb, angular3PointDim);
                break;
            case OrdinateDimension ordinateDim when options.GenerateAllEntities || options.GenerateDimensionEntities:
                GenerateOrdinateDimension(sb, ordinateDim);
                break;
            case Ray ray when options.GenerateAllEntities || options.GenerateRayEntities:
                GenerateRay(sb, ray);
                break;
            case XLine xline when options.GenerateAllEntities || options.GenerateXLineEntities:
                GenerateXLine(sb, xline);
                break;
            case Solid solid when options.GenerateAllEntities || options.GenerateSolidEntities:
                GenerateSolid(sb, solid);
                break;
            case MLine mline when options.GenerateAllEntities || options.GenerateMLineEntities:
                GenerateMLine(sb, mline);
                break;
            default:
                 if (options.GenerateDetailedComments)
                 {
                     sb.AppendLine($"        // Skipped entity type: {entity.GetType().Name}");
                 }
                 break;
        }
    }

    private void GenerateLine(StringBuilder sb, Line line)
    {
        sb.AppendLine("        doc.Entities.Add(");
        GenerateLineConstructor(sb, line, "        ");
        GenerateEntityProperties(sb, line);
        sb.AppendLine("        );");
    }

    private void GenerateLineConstructor(StringBuilder sb, Line line, string indent)
    {
        sb.AppendLine($"{indent}new Line(");
        sb.AppendLine($"{indent}    new Vector3({F(line.StartPoint.X)}, {F(line.StartPoint.Y)}, {F(line.StartPoint.Z)}),");
        sb.AppendLine($"{indent}    new Vector3({F(line.EndPoint.X)}, {F(line.EndPoint.Y)}, {F(line.EndPoint.Z)}))");
    }

    private void GenerateArc(StringBuilder sb, Arc arc)
    {
        sb.AppendLine("        doc.Entities.Add(");
        GenerateArcConstructor(sb, arc, "        ");
        GenerateEntityProperties(sb, arc);
        sb.AppendLine("        );");
    }

    private void GenerateArcConstructor(StringBuilder sb, Arc arc, string indent)
    {
        sb.AppendLine($"{indent}new Arc(");
        sb.AppendLine($"{indent}    new Vector3({F(arc.Center.X)}, {F(arc.Center.Y)}, {F(arc.Center.Z)}),");
        sb.AppendLine($"{indent}    {F(arc.Radius)}, {F(arc.StartAngle)}, {F(arc.EndAngle)})");
    }

    private void GenerateCircle(StringBuilder sb, Circle circle)
    {
        sb.AppendLine("        doc.Entities.Add(");
        GenerateCircleConstructor(sb, circle, "        ");
        GenerateEntityProperties(sb, circle);
        sb.AppendLine("        );");
    }

    private void GenerateCircleConstructor(StringBuilder sb, Circle circle, string indent)
    {
        sb.AppendLine($"{indent}new Circle(");
        sb.AppendLine($"{indent}    new Vector3({F(circle.Center.X)}, {F(circle.Center.Y)}, {F(circle.Center.Z)}),");
        sb.AppendLine($"{indent}    {F(circle.Radius)})");
    }

    private void GeneratePoint(StringBuilder sb, PointEntity point)
    {
        sb.AppendLine($"        doc.Entities.Add(new Point(");
        sb.AppendLine($"            new Vector3({F(point.Position.X)}, {F(point.Position.Y)}, {F(point.Position.Z)}))");
        GenerateEntityProperties(sb, point);
        sb.AppendLine("        );");
    }

    private void GeneratePolyline2D(StringBuilder sb, Polyline2D poly2d)
    {
        sb.AppendLine("        doc.Entities.Add(");
        GeneratePolyline2DConstructor(sb, poly2d, "        ");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, poly2d);
        if (Math.Abs(poly2d.Elevation) > 1e-12)
        {
            sb.AppendLine($"            Elevation = {F(poly2d.Elevation)},");
        }
        sb.AppendLine("        }");
        sb.AppendLine("        );");
    }

    private void GeneratePolyline2DConstructor(StringBuilder sb, Polyline2D poly2d, string indent)
    {
        sb.AppendLine($"{indent}new Polyline2D(new List<Polyline2DVertex>()");
        sb.AppendLine($"{indent}{{");
        foreach (var vertex in poly2d.Vertexes)
        {
            string bulgeStr = Math.Abs(vertex.Bulge) > 1e-12 ? $" {{ Bulge = {F(vertex.Bulge)} }}" : "";
            sb.AppendLine($"{indent}    new Polyline2DVertex({F(vertex.Position.X)}, {F(vertex.Position.Y)}){bulgeStr},");
        }
        sb.AppendLine($"{indent}}}, {(poly2d.IsClosed ? "true" : "false")})");
    }

    private void GeneratePolyline3D(StringBuilder sb, Polyline3D poly3d)
    {
        sb.AppendLine("        doc.Entities.Add(new Polyline3D(new List<Polyline3DVertex>()");
        sb.AppendLine("        {");
        foreach (var v in poly3d.Vertexes)
        {
            sb.AppendLine($"            new Polyline3DVertex({F(v.X)}, {F(v.Y)}, {F(v.Z)}),");
        }
        sb.AppendLine($"        }}, {(poly3d.IsClosed ? "true" : "false")})");
        GenerateEntityProperties(sb, poly3d);
        sb.AppendLine("        );");
    }

    private void GenerateSpline(StringBuilder sb, Spline spline)
    {
        // Generate spline with complete definition: control points, weights, and degree
        sb.AppendLine("        {");
        sb.AppendLine("            var controlPoints = new List<Vector3>");
        sb.AppendLine("            {");
        foreach (var cp in spline.ControlPoints)
        {
            sb.AppendLine($"                new Vector3({F(cp.X)}, {F(cp.Y)}, {F(cp.Z)}),");
        }
        sb.AppendLine("            };");
        sb.AppendLine();
        
        sb.AppendLine("            var weights = new List<double>");
        sb.AppendLine("            {");
        foreach (var weight in spline.Weights)
        {
            sb.AppendLine($"                {F(weight)},");
        }
        sb.AppendLine("            };");
        sb.AppendLine();
        
        sb.AppendLine($"            var splineEntity = new Spline(controlPoints, weights, {spline.Degree});");
        
        // Apply entity properties
        if (spline.Layer != null && _usedLayers.Contains(spline.Layer.Name))
        {
            sb.AppendLine($"            splineEntity.Layer = layer{SafeName(spline.Layer.Name)};");
        }
        
        // Color handling
        if (spline.Color.Index != 256) // Not ByLayer
        {
            if (spline.Color.Index == 0)
                sb.AppendLine("            splineEntity.Color = AciColor.ByBlock;");
            else if (spline.Color.Index >= 1 && spline.Color.Index <= 255)
                sb.AppendLine($"            splineEntity.Color = new AciColor({spline.Color.Index});");
        }
        
        // Linetype
        if (spline.Linetype != null && spline.Linetype.Name != "ByLayer" && spline.Linetype.Name != "Continuous")
        {
            sb.AppendLine($"            splineEntity.Linetype = linetype{SafeName(spline.Linetype.Name)};");
        }
        
        // Lineweight
        if (spline.Lineweight != Lineweight.ByLayer)
        {
            sb.AppendLine($"            splineEntity.Lineweight = Lineweight.{spline.Lineweight};");
        }
        
        // Linetype scale
        if (Math.Abs(spline.LinetypeScale - 1.0) > 1e-10)
        {
            sb.AppendLine($"            splineEntity.LinetypeScale = {F(spline.LinetypeScale)};");
        }
        
        sb.AppendLine("            doc.Entities.Add(splineEntity);");
        sb.AppendLine("        }");
    }

    private void GenerateSplineConstructor(StringBuilder sb, Spline spline, string indent)
    {
        sb.AppendLine($"{indent}new Spline(");
        sb.AppendLine($"{indent}    new List<Vector3>()");
        sb.AppendLine($"{indent}    {{");
        foreach (var cp in spline.ControlPoints)
        {
            sb.AppendLine($"{indent}        new Vector3({F(cp.X)}, {F(cp.Y)}, {F(cp.Z)}),");
        }
        sb.AppendLine($"{indent}    }},");
        sb.AppendLine($"{indent}    new List<double>()");
        sb.AppendLine($"{indent}    {{");
        foreach (var weight in spline.Weights)
        {
            sb.AppendLine($"{indent}        {F(weight)},");
        }
        sb.AppendLine($"{indent}    }},");
        sb.AppendLine($"{indent}    {spline.Degree})");
    }

    private void GenerateText(StringBuilder sb, Text text)
    {
        sb.AppendLine($"        doc.Entities.Add(new Text(");
        sb.AppendLine($"            \"{Escape(text.Value)}\",");
        sb.AppendLine($"            new Vector3({F(text.Position.X)}, {F(text.Position.Y)}, {F(text.Position.Z)}),");
        sb.AppendLine($"            {F(text.Height)})");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, text);
        if (text.Style?.Name != "Standard")
        {
            sb.AppendLine($"            Style = textStyle{SafeName(text.Style?.Name ?? "Standard")},");
        }
        if (Math.Abs(text.Rotation) > 1e-12)
        {
            sb.AppendLine($"            Rotation = {F(text.Rotation)},");
        }
        sb.AppendLine("        }");
        sb.AppendLine("        );");
    }

    private void GenerateMText(StringBuilder sb, MText mtext)
    {
        sb.AppendLine($"        doc.Entities.Add(new MText(");
        sb.AppendLine($"            \"{EscapeMText(mtext.Value)}\",");
        sb.AppendLine($"            new Vector3({F(mtext.Position.X)}, {F(mtext.Position.Y)}, {F(mtext.Position.Z)}),");
        sb.AppendLine($"            {F(mtext.Height)})");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, mtext);
        if (mtext.Style?.Name != "Standard")
        {
            sb.AppendLine($"            Style = textStyle{SafeName(mtext.Style?.Name ?? "Standard")},");
        }
        if (mtext.RectangleWidth > 0)
        {
            sb.AppendLine($"            RectangleWidth = {F(mtext.RectangleWidth)},");
        }
        sb.AppendLine("        }");
        sb.AppendLine("        );");
    }

    private void GenerateEllipse(StringBuilder sb, Ellipse ellipse)
    {
        sb.AppendLine("        doc.Entities.Add(");
        GenerateEllipseConstructor(sb, ellipse, "        ");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, ellipse);
        if (Math.Abs(ellipse.StartAngle) > 1e-12 || Math.Abs(ellipse.EndAngle - 360) > 1e-12)
        {
            sb.AppendLine($"            StartAngle = {F(ellipse.StartAngle)},");
            sb.AppendLine($"            EndAngle = {F(ellipse.EndAngle)},");
        }
        sb.AppendLine("        }");
        sb.AppendLine("        );");
    }

    private void GenerateEllipseConstructor(StringBuilder sb, Ellipse ellipse, string indent)
    {
        sb.AppendLine($"{indent}new Ellipse(");
        sb.AppendLine($"{indent}    new Vector3({F(ellipse.Center.X)}, {F(ellipse.Center.Y)}, {F(ellipse.Center.Z)}),");
        sb.AppendLine($"{indent}    {F(ellipse.MajorAxis)}, {F(ellipse.MinorAxis)})");
    }

    private void GenerateEntityProperties(StringBuilder sb, EntityObject entity)
    {
        sb.AppendLine("        {");

        // Layer
        if (entity.Layer != null && _usedLayers.Contains(entity.Layer.Name))
        {
            sb.AppendLine($"            Layer = layer{SafeName(entity.Layer.Name)},");
        }

        // Color (if not ByLayer)
        if (entity.Color.Index != 256) // 256 = ByLayer
        {
            if (entity.Color.Index == 0)
                sb.AppendLine("            Color = AciColor.ByBlock,");
            else if (entity.Color.Index >= 1 && entity.Color.Index <= 255)
                sb.AppendLine($"            Color = new AciColor({entity.Color.Index}),");
            // Note: TrueColor emission omitted to avoid API differences across versions
        }

        // Linetype
        if (entity.Linetype != null && entity.Linetype.Name != "ByLayer" && entity.Linetype.Name != "Continuous")
        {
            sb.AppendLine($"            Linetype = linetype{SafeName(entity.Linetype.Name)},");
        }

        // Lineweight
        if (entity.Lineweight != Lineweight.ByLayer)
        {
            sb.AppendLine($"            Lineweight = Lineweight.{entity.Lineweight},");
        }

        // Linetype scale
        if (Math.Abs(entity.LinetypeScale - 1.0) > 1e-10)
        {
            sb.AppendLine($"            LinetypeScale = {F(entity.LinetypeScale)},");
        }

        // Thickness (only for entities that support it in netDxf 3.0.1)
        if (entity is Line line && Math.Abs(line.Thickness) > 1e-10)
        {
            sb.AppendLine($"            Thickness = {F(line.Thickness)},");
        }
        else if (entity is Arc arc && Math.Abs(arc.Thickness) > 1e-10)
        {
            sb.AppendLine($"            Thickness = {F(arc.Thickness)},");
        }
        else if (entity is Circle circle && Math.Abs(circle.Thickness) > 1e-10)
        {
            sb.AppendLine($"            Thickness = {F(circle.Thickness)},");
        }
        else if (entity is Polyline2D poly2d && Math.Abs(poly2d.Thickness) > 1e-10)
        {
            sb.AppendLine($"            Thickness = {F(poly2d.Thickness)},");
        }
        else if (entity is Solid solid && Math.Abs(solid.Thickness) > 1e-10)
        {
            sb.AppendLine($"            Thickness = {F(solid.Thickness)},");
        }

        // Normal (if not default 0,0,1)
        var n = entity.Normal;
        if (Math.Abs(n.X) > 1e-12 || Math.Abs(n.Y) > 1e-12 || Math.Abs(n.Z - 1.0) > 1e-12)
        {
            sb.AppendLine($"            Normal = new Vector3({F(n.X)}, {F(n.Y)}, {F(n.Z)}),");
        }

        sb.AppendLine("        }");
    }

    private void GenerateEntityPropertiesCore(StringBuilder sb, EntityObject entity)
    {
        // Layer
        if (entity.Layer != null && _usedLayers.Contains(entity.Layer.Name))
        {
            sb.AppendLine($"            Layer = layer{SafeName(entity.Layer.Name)},");
        }

        // Color (if not ByLayer)
        if (entity.Color.Index != 256) // 256 = ByLayer
        {
            if (entity.Color.Index == 0)
                sb.AppendLine("            Color = AciColor.ByBlock,");
            else if (entity.Color.Index >= 1 && entity.Color.Index <= 255)
                sb.AppendLine($"            Color = new AciColor({entity.Color.Index}),");
            // Note: TrueColor emission omitted to avoid API differences across versions
        }

        // Linetype
        if (entity.Linetype != null && entity.Linetype.Name != "ByLayer" && entity.Linetype.Name != "Continuous")
        {
            sb.AppendLine($"            Linetype = linetype{SafeName(entity.Linetype.Name)},");
        }

        // Lineweight
        if (entity.Lineweight != Lineweight.ByLayer)
        {
            sb.AppendLine($"            Lineweight = Lineweight.{entity.Lineweight},");
        }

        // Linetype scale
        if (Math.Abs(entity.LinetypeScale - 1.0) > 1e-10)
        {
            sb.AppendLine($"            LinetypeScale = {F(entity.LinetypeScale)},");
        }

        // Thickness (only for entities that support it in netDxf 3.0.1)
        if (entity is Line line && Math.Abs(line.Thickness) > 1e-10)
        {
            sb.AppendLine($"            Thickness = {F(line.Thickness)},");
        }
        else if (entity is Arc arc && Math.Abs(arc.Thickness) > 1e-10)
        {
            sb.AppendLine($"            Thickness = {F(arc.Thickness)},");
        }
        else if (entity is Circle circle && Math.Abs(circle.Thickness) > 1e-10)
        {
            sb.AppendLine($"            Thickness = {F(circle.Thickness)},");
        }
        else if (entity is Polyline2D poly2d && Math.Abs(poly2d.Thickness) > 1e-10)
        {
            sb.AppendLine($"            Thickness = {F(poly2d.Thickness)},");
        }

        // Normal (if not default 0,0,1)
        var n = entity.Normal;
        if (Math.Abs(n.X) > 1e-12 || Math.Abs(n.Y) > 1e-12 || Math.Abs(n.Z - 1.0) > 1e-12)
        {
            sb.AppendLine($"            Normal = new Vector3({F(n.X)}, {F(n.Y)}, {F(n.Z)}),");
        }
    }

    private void GenerateBlockEntity(StringBuilder sb, EntityObject entity, string blockName, DxfCodeGenerationOptions options)
    {
        // Reuse existing entity generation methods by temporarily modifying the output
        var tempSb = new StringBuilder();
        GenerateEntity(tempSb, entity, options);
        
        // Replace "doc.Entities.Add(" with "block{blockName}.Entities.Add("
        var entityCode = tempSb.ToString();
        var modifiedCode = entityCode.Replace("doc.Entities.Add(", $"block{SafeName(blockName)}.Entities.Add(");
        
        sb.Append(modifiedCode);
    }

    private void GenerateInsert(StringBuilder sb, Insert insert)
    {
        var blkName = insert.Block?.Name;
        if (string.IsNullOrEmpty(blkName))
        {
            sb.AppendLine("        // Insert with null block skipped");
            return;
        }
        var safeBlk = SafeName(blkName!);
        var insertVarName = $"ins_{safeBlk}_{_insertCounter++}";
        sb.AppendLine($"        var {insertVarName} = new Insert(block{safeBlk})");
        sb.AppendLine("        {");
        sb.AppendLine($"            Position = new Vector3({F(insert.Position.X)}, {F(insert.Position.Y)}, {F(insert.Position.Z)}),");
        if (Math.Abs(insert.Scale.X - 1.0) > 1e-12 || Math.Abs(insert.Scale.Y - 1.0) > 1e-12 || Math.Abs(insert.Scale.Z - 1.0) > 1e-12)
            sb.AppendLine($"            Scale = new Vector3({F(insert.Scale.X)}, {F(insert.Scale.Y)}, {F(insert.Scale.Z)}),");
        if (Math.Abs(insert.Rotation) > 1e-12)
            sb.AppendLine($"            Rotation = {F(insert.Rotation)},");
        if (insert.Layer != null && _usedLayers.Contains(insert.Layer.Name))
            sb.AppendLine($"            Layer = layer{SafeName(insert.Layer.Name)},");
        sb.AppendLine("        };");

        // Attributes
        if (insert.Attributes != null && insert.Attributes.Count > 0)
        {
            foreach (var att in insert.Attributes)
            {
                // Assign value by tag when possible
                if (!string.IsNullOrEmpty(att.Tag))
                {
                    sb.AppendLine($"        var attr_{SafeName(att.Tag)} = {insertVarName}.Attributes.AttributeWithTag(\"{Escape(att.Tag)}\");");
                    sb.AppendLine($"        if (attr_{SafeName(att.Tag)} != null) attr_{SafeName(att.Tag)}.Value = \"{Escape(att.Value)}\";");
                }
            }
        }

        sb.AppendLine($"        doc.Entities.Add({insertVarName});");
        sb.AppendLine();
    }

    private static string Escape(string s) => s.Replace("\\", "\\\\").Replace("\"", "\\\"");
    
    private static string EscapeMText(string s) => s.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\n", "\\P");
    
    private static string SafeName(string name)
    {
        // Convert layer/table names to safe C# identifiers
        var result = new StringBuilder();
        foreach (char c in name)
        {
            if (char.IsLetterOrDigit(c))
                result.Append(c);
            else
                result.Append('_');
        }
        var safeName = result.ToString();
        if (char.IsDigit(safeName[0]))
            safeName = "_" + safeName;
        return safeName;
    }

    private void GenerateHatch(StringBuilder sb, Hatch hatch, DxfCodeGenerationOptions options)
    {
        // Generate Hatch with boundary paths reconstruction
        var patternName = hatch.Pattern?.Name ?? "SOLID";
        var isSolid = string.Equals(patternName, "SOLID", StringComparison.OrdinalIgnoreCase) || string.Equals(patternName, "Solid", StringComparison.OrdinalIgnoreCase);
        
        sb.AppendLine("        {");
        sb.AppendLine("            // Hatch with boundary paths");
        sb.AppendLine("            var boundaryPaths = new List<HatchBoundaryPath>();");
        
        // Reconstruct boundary paths from existing hatch boundary paths
        if (hatch.BoundaryPaths != null && hatch.BoundaryPaths.Count > 0)
        {
            for (int i = 0; i < hatch.BoundaryPaths.Count; i++)
            {
                var path = hatch.BoundaryPaths[i];
                sb.AppendLine($"            // Boundary path {i + 1}");
                sb.AppendLine($"            var pathEntities{i} = new List<EntityObject>();");
                
                // Extract entities from the boundary path edges
                if (path.Edges.Count > 0)
                {
                    foreach (var edge in path.Edges)
                    {
                        var entityObj = edge.ConvertTo();
                        if (entityObj != null)
                        {
                            GenerateBoundaryEntity(sb, entityObj, options, i);
                        }
                    }
                }
                
                sb.AppendLine($"            boundaryPaths.Add(new HatchBoundaryPath(pathEntities{i}));");
                sb.AppendLine();
            }
        }
        
        // Create the hatch with the pattern and boundaries
        if (isSolid)
        {
            sb.AppendLine("            var hatchEntity = new Hatch(HatchPattern.Solid, boundaryPaths, false);");
        }
        else
        {
            sb.AppendLine($"            var hatchEntity = new Hatch(new HatchPattern(\"{Escape(patternName)}\"), boundaryPaths, false);");
        }
        
        sb.AppendLine($"            hatchEntity.Elevation = {F(hatch.Elevation)};");
        
        // Apply entity properties
        if (hatch.Layer != null && _usedLayers.Contains(hatch.Layer.Name))
        {
            sb.AppendLine($"            hatchEntity.Layer = layer{SafeName(hatch.Layer.Name)};");
        }
        
        // Color handling
        if (hatch.Color.Index != 256) // Not ByLayer
        {
            if (hatch.Color.Index == 0)
                sb.AppendLine("            hatchEntity.Color = AciColor.ByBlock;");
            else
                sb.AppendLine($"            hatchEntity.Color = new AciColor({hatch.Color.Index});");
        }
        
        sb.AppendLine("            doc.Entities.Add(hatchEntity);");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private void GenerateBoundaryEntity(StringBuilder sb, EntityObject entity, DxfCodeGenerationOptions options, int pathIndex)
    {
        // Generate entity creation code for boundary paths without properties
        sb.AppendLine($"            pathEntities{pathIndex}.Add(");
        
        switch (entity)
        {
            case Line line:
                GenerateLineConstructor(sb, line, "            ");
                break;
            case Arc arc:
                GenerateArcConstructor(sb, arc, "            ");
                break;
            case Circle circle:
                GenerateCircleConstructor(sb, circle, "            ");
                break;
            case Polyline2D poly2d:
                GeneratePolyline2DConstructor(sb, poly2d, "            ");
                break;
            case Ellipse ellipse:
                GenerateEllipseConstructor(sb, ellipse, "            ");
                break;
            case Spline spline:
                GenerateSplineConstructor(sb, spline, "            ");
                break;
            default:
                // Fallback for other entity types
                sb.AppendLine($"            // Unsupported boundary entity type: {entity.GetType().Name}");
                sb.AppendLine("            null");
                break;
        }
        
        sb.AppendLine("            );");
    }

    private void GenerateWipeout(StringBuilder sb, Wipeout wipeout)
    {
        sb.AppendLine("        {");
        sb.AppendLine("            // Wipeout entity with clipping boundary");
        sb.AppendLine("            var boundaryVertices = new List<Vector2>();");
        
        if (wipeout.ClippingBoundary != null && wipeout.ClippingBoundary.Vertexes.Count > 0)
        {
            foreach (var vertex in wipeout.ClippingBoundary.Vertexes)
            {
                sb.AppendLine($"            boundaryVertices.Add(new Vector2({F(vertex.X)}, {F(vertex.Y)}));");
            }
        }
        
        sb.AppendLine("            var wipeoutEntity = new Wipeout(boundaryVertices);");
        
        // Apply entity properties
        if (wipeout.Layer != null && _usedLayers.Contains(wipeout.Layer.Name))
        {
            sb.AppendLine($"            wipeoutEntity.Layer = layer{SafeName(wipeout.Layer.Name)};");
        }
        
        sb.AppendLine("            doc.Entities.Add(wipeoutEntity);");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private void GenerateLeader(StringBuilder sb, Leader leader)
    {
        sb.AppendLine("        {");
        sb.AppendLine("            // Leader entity with vertices");
        sb.AppendLine("            var leaderVertices = new List<Vector2>();");
        
        if (leader.Vertexes != null && leader.Vertexes.Count > 0)
        {
            foreach (var vertex in leader.Vertexes)
            {
                sb.AppendLine($"            leaderVertices.Add(new Vector2({F(vertex.X)}, {F(vertex.Y)}));");
            }
        }
        
        sb.AppendLine("            var leaderEntity = new Leader(leaderVertices);");
        
        // Apply entity properties
        if (leader.Layer != null && _usedLayers.Contains(leader.Layer.Name))
        {
            sb.AppendLine($"            leaderEntity.Layer = layer{SafeName(leader.Layer.Name)};");
        }
        
        // Color handling
        if (leader.Color.Index != 256) // Not ByLayer
        {
            if (leader.Color.Index == 0)
                sb.AppendLine("            leaderEntity.Color = AciColor.ByBlock;");
            else
                sb.AppendLine($"            leaderEntity.Color = new AciColor({leader.Color.Index});");
        }
        
        sb.AppendLine("            doc.Entities.Add(leaderEntity);");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private void GenerateFace3D(StringBuilder sb, Face3D face3d)
    {
        sb.AppendLine($"        doc.Entities.Add(new Face3D(");
        sb.AppendLine($"            new Vector3({F(face3d.FirstVertex.X)}, {F(face3d.FirstVertex.Y)}, {F(face3d.FirstVertex.Z)}),");
        sb.AppendLine($"            new Vector3({F(face3d.SecondVertex.X)}, {F(face3d.SecondVertex.Y)}, {F(face3d.SecondVertex.Z)}),");
        sb.AppendLine($"            new Vector3({F(face3d.ThirdVertex.X)}, {F(face3d.ThirdVertex.Y)}, {F(face3d.ThirdVertex.Z)}),");
        sb.AppendLine($"            new Vector3({F(face3d.FourthVertex.X)}, {F(face3d.FourthVertex.Y)}, {F(face3d.FourthVertex.Z)}))");
        sb.AppendLine("        {");
        GenerateEntityPropertiesCore(sb, face3d);
        
        // EdgeFlags
        if (face3d.EdgeFlags != Face3DEdgeFlags.None)
        {
            var edgeFlagsStr = GenerateEnumFlags(face3d.EdgeFlags);
            sb.AppendLine($"            EdgeFlags = {edgeFlagsStr},");
        }
        
        sb.AppendLine("        }");
        sb.AppendLine("        );");
    }

    private void GenerateLinearDimension(StringBuilder sb, LinearDimension dimension)
    {
        sb.AppendLine($"        doc.Entities.Add(new LinearDimension(");
        sb.AppendLine($"            new Vector2({F(dimension.FirstReferencePoint.X)}, {F(dimension.FirstReferencePoint.Y)}),");
        sb.AppendLine($"            new Vector2({F(dimension.SecondReferencePoint.X)}, {F(dimension.SecondReferencePoint.Y)}),");
        sb.AppendLine($"            {F(dimension.Offset)}, {F(dimension.Rotation)})");
        GenerateEntityProperties(sb, dimension);
        sb.AppendLine("        );");
    }

    private void GenerateAlignedDimension(StringBuilder sb, AlignedDimension dimension)
    {
        sb.AppendLine($"        doc.Entities.Add(new AlignedDimension(");
        sb.AppendLine($"            new Vector2({F(dimension.FirstReferencePoint.X)}, {F(dimension.FirstReferencePoint.Y)}),");
        sb.AppendLine($"            new Vector2({F(dimension.SecondReferencePoint.X)}, {F(dimension.SecondReferencePoint.Y)}),");
        sb.AppendLine($"            {F(dimension.Offset)})");
        GenerateEntityProperties(sb, dimension);
        sb.AppendLine("        );");
    }

    private void GenerateRadialDimension(StringBuilder sb, RadialDimension dimension)
    {
        sb.AppendLine($"        doc.Entities.Add(new RadialDimension(");
        sb.AppendLine($"            new Vector2({F(dimension.CenterPoint.X)}, {F(dimension.CenterPoint.Y)}),");
        sb.AppendLine($"            new Vector2({F(dimension.ReferencePoint.X)}, {F(dimension.ReferencePoint.Y)})");
        GenerateEntityProperties(sb, dimension);
        sb.AppendLine("        );");
    }

    private void GenerateDiametricDimension(StringBuilder sb, DiametricDimension dimension)
    {
        sb.AppendLine($"        doc.Entities.Add(new DiametricDimension(");
        sb.AppendLine($"            new Vector2({F(dimension.CenterPoint.X)}, {F(dimension.CenterPoint.Y)}),");
        sb.AppendLine($"            new Vector2({F(dimension.ReferencePoint.X)}, {F(dimension.ReferencePoint.Y)})");
        sb.AppendLine($"        )");
        GenerateEntityProperties(sb, dimension);
        sb.AppendLine("        );");
    }

    private void GenerateAngular2LineDimension(StringBuilder sb, Angular2LineDimension dimension)
    {
        sb.AppendLine($"        doc.Entities.Add(new Angular2LineDimension(");
        sb.AppendLine($"            new Vector2({F(dimension.StartFirstLine.X)}, {F(dimension.StartFirstLine.Y)}),");
        sb.AppendLine($"            new Vector2({F(dimension.EndFirstLine.X)}, {F(dimension.EndFirstLine.Y)}),");
        sb.AppendLine($"            new Vector2({F(dimension.StartSecondLine.X)}, {F(dimension.StartSecondLine.Y)}),");
        sb.AppendLine($"            new Vector2({F(dimension.EndSecondLine.X)}, {F(dimension.EndSecondLine.Y)}),");
        sb.AppendLine($"            {F(dimension.Offset)})");
        GenerateEntityProperties(sb, dimension);
        sb.AppendLine("        );");
    }

    private void GenerateAngular3PointDimension(StringBuilder sb, Angular3PointDimension dimension)
    {
        sb.AppendLine($"        doc.Entities.Add(new Angular3PointDimension(");
        sb.AppendLine($"            new Vector2({F(dimension.CenterPoint.X)}, {F(dimension.CenterPoint.Y)}),");
        sb.AppendLine($"            new Vector2({F(dimension.StartPoint.X)}, {F(dimension.StartPoint.Y)}),");
        sb.AppendLine($"            new Vector2({F(dimension.EndPoint.X)}, {F(dimension.EndPoint.Y)}),");
        sb.AppendLine($"            {F(dimension.Offset)})");
        GenerateEntityProperties(sb, dimension);
        sb.AppendLine("        );");
    }

    private void GenerateOrdinateDimension(StringBuilder sb, OrdinateDimension dimension)
    {
        sb.AppendLine($"        doc.Entities.Add(new OrdinateDimension(");
        sb.AppendLine($"            Vector2.Zero,");
        sb.AppendLine($"            new Vector2({F(dimension.FeaturePoint.X)}, {F(dimension.FeaturePoint.Y)}),");
        sb.AppendLine($"            new Vector2({F(dimension.LeaderEndPoint.X)}, {F(dimension.LeaderEndPoint.Y)}),");
        sb.AppendLine($"            OrdinateDimensionAxis.{dimension.Axis})");
        GenerateEntityProperties(sb, dimension);
        sb.AppendLine("        );");
    }

    private void GenerateRay(StringBuilder sb, Ray ray)
    {
        sb.AppendLine($"        doc.Entities.Add(new Ray(");
        sb.AppendLine($"            new Vector3({F(ray.Origin.X)}, {F(ray.Origin.Y)}, {F(ray.Origin.Z)}),");
        sb.AppendLine($"            new Vector3({F(ray.Direction.X)}, {F(ray.Direction.Y)}, {F(ray.Direction.Z)}))");
        GenerateEntityProperties(sb, ray);
        sb.AppendLine("        );");
    }

    private void GenerateXLine(StringBuilder sb, XLine xline)
    {
        sb.AppendLine($"        doc.Entities.Add(new XLine(");
        sb.AppendLine($"            new Vector3({F(xline.Origin.X)}, {F(xline.Origin.Y)}, {F(xline.Origin.Z)}),");
        sb.AppendLine($"            new Vector3({F(xline.Direction.X)}, {F(xline.Direction.Y)}, {F(xline.Direction.Z)}))");
        GenerateEntityProperties(sb, xline);
        sb.AppendLine("        );");
    }

    private void GenerateSolid(StringBuilder sb, Solid solid)
    {
        sb.AppendLine($"        doc.Entities.Add(new Solid(");
        sb.AppendLine($"            new Vector2({F(solid.FirstVertex.X)}, {F(solid.FirstVertex.Y)}),");
        sb.AppendLine($"            new Vector2({F(solid.SecondVertex.X)}, {F(solid.SecondVertex.Y)}),");
        sb.AppendLine($"            new Vector2({F(solid.ThirdVertex.X)}, {F(solid.ThirdVertex.Y)}),");
        sb.AppendLine($"            new Vector2({F(solid.FourthVertex.X)}, {F(solid.FourthVertex.Y)}))");
        GenerateEntityProperties(sb, solid);
        sb.AppendLine("        );");
    }

    private void GenerateMLine(StringBuilder sb, MLine mline)
    {
        sb.AppendLine("        {");
        sb.AppendLine("            // MLine entity with vertices");
        sb.AppendLine("            var mlineVertices = new List<Vector2>();");
        
        if (mline.Vertexes != null && mline.Vertexes.Count > 0)
        {
            foreach (var vertex in mline.Vertexes)
            {
                sb.AppendLine($"            mlineVertices.Add(new Vector2({F(vertex.Position.X)}, {F(vertex.Position.Y)}));");
            }
        }
        
        sb.AppendLine("            var mlineEntity = new MLine(mlineVertices);");
        
        // Apply entity properties
        if (mline.Layer != null && _usedLayers.Contains(mline.Layer.Name))
        {
            sb.AppendLine($"            mlineEntity.Layer = layer{SafeName(mline.Layer.Name)};");
        }
        
        // Color handling
        if (mline.Color.Index != 256) // Not ByLayer
        {
            if (mline.Color.Index == 0)
                sb.AppendLine("            mlineEntity.Color = AciColor.ByBlock;");
            else
                sb.AppendLine($"            mlineEntity.Color = new AciColor({mline.Color.Index});");
        }
        
        sb.AppendLine("            doc.Entities.Add(mlineEntity);");
        sb.AppendLine("        }");
        sb.AppendLine();
    }
}
